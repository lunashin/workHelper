<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Fabric.js 図形作成ツール（スロット保存・復元・エクスポート対応）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --fg:#0f172a;
      --line:#3a3c44;
      --slotBg:#f5f7fb;
      --slotSel:#0ea5e9;
      --slotTxt:#0b1323;
    }
    html,body{
      height:100%;
      margin:0;
      color:var(--fg);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"ヒラギノ角ゴ ProN",Meiryo,sans-serif;
    }
    header{
      padding:10px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      gap:18px;
      align-items:center;
      flex-wrap:wrap;
    }
    .kbd{
      padding:.2em .45em;
      border:1px solid var(--line);
      border-bottom-width:2px;
      border-radius:6px;
      font-weight:600;
      background:#f2f3f5;
    }
    #wrap{
      height:calc(100% - 104px); /* header + toolbar 分を考慮 */
    }
    /* 下レイヤー（描画側）だけ白背景にする */
    #stage{ display:block; outline:none; background:#fff; }
    /* 上レイヤー（選択オーバーレイ）は必ず透明 */
    .upper-canvas{ background: transparent !important; }

    /* スロットツールバー */
    #toolbar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 14px;
      border-bottom:1px solid var(--line);
      background:#fafbff;
      flex-wrap:wrap;
    }
    .slot-btn{
      min-width:38px;
      padding:6px 10px;
      border:1px solid #cfd6e3;
      border-radius:8px;
      background:var(--slotBg);
      color:var(--slotTxt);
      font-weight:600;
      cursor:pointer;
      user-select:none;
    }
    .slot-btn.active{
      border-color:var(--slotSel);
      box-shadow:0 0 0 2px rgba(14,165,233,.2) inset;
      color:var(--slotSel);
      background:#e8f6fd;
    }
    .toolbar-button{
      padding:6px 12px;
      border:1px solid #cfd6e3;
      border-radius:8px;
      background:#ffffff;
      font-weight:600;
      cursor:pointer;
    }
    .toolbar-button:hover{ background:#f6f8fc; }
    .spacer{ flex:1 1 auto; }
  </style>
</head>





<body>
  <header id="header">
    <div>
      <span class="kbd">c</span> 円 /
      <span class="kbd">s</span> 四角 /
      <span class="kbd">t</span> テキスト /
      <span class="kbd">a</span> 線：始点確定 → プレビュー → クリックで終点確定
    </div>
    <div>ダブルクリック/Enter でテキスト編集／Space で色変更／Ctrl|Cmd+D で複製</div>
  </header>

  <!-- 保存スロット & エクスポート -->
  <div id="toolbar" aria-label="保存スロットとエクスポート">
    <div id="slotButtons"></div>
    <div class="spacer"></div>
    <button id="importBtn" class="toolbar-button" type="button" title="JSONを現在のスロットにインポート">JSONインポート</button>
    <button id="exportBtn" class="toolbar-button" type="button" title="現在の状態をJSONでエクスポート">JSONエクスポート</button>
    <button id="clearBtn" class="toolbar-button"  type="button" title="現在のスロットをクリア">クリア</button>
  </div>

  <div id="wrap">
    <canvas id="stage" tabindex="0" aria-label="図形キャンバス"></canvas>
  </div>





  <!-- Fabric.js v6.7.1 (cdnjs/671) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/671/index.min.js"></script>
  <script>
  (function(){
    /** @type {HTMLCanvasElement} */
    const canvasEl = document.getElementById('stage');
    /** @type {HTMLElement} */
    const headerEl = document.getElementById('header');
    /** @type {HTMLElement} */
    const toolbarEl = document.getElementById('toolbar');

    /** @type {HTMLElement} */
    const slotButtonsEl = document.getElementById('slotButtons');
    /** @type {HTMLButtonElement} */
    const exportBtn = document.getElementById('exportBtn');
    /** @type {HTMLButtonElement} */
    const importBtn = document.getElementById('importBtn');
    /** @type {HTMLButtonElement} */
    const clearBtn  = document.getElementById('clearBtn');

    /** @type {fabric.Canvas} Fabric キャンバス本体 */
    const canvas = new fabric.Canvas(canvasEl, {
      backgroundColor: '#ffffff',
      selection: true,
      preserveObjectStacking: true
    });

    // --- 既存：コントロールの見やすさ（任意・一括設定） ---
    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.cornerColor = '#0ea5e9';
    fabric.Object.prototype.cornerStyle = 'rect';
    fabric.Object.prototype.cornerSize = 10;
    fabric.Object.prototype.borderColor = '#0ea5e9';

    // --- 既存：色パレット（Spaceでローテーション） ---
    const color_palette = ['#60a5fa','#22c55e','#f59e0b','#ef4444','#a78bfa'];

    /**
     * 画面サイズに合わせて Canvas を調整
     * @returns {void}
     */
    function resizeCanvasToViewport(){
      const viewportWidth  = window.innerWidth;
      const viewportHeight = window.innerHeight;
      // const headerHeight   = Math.ceil(headerEl.getBoundingClientRect().height) + 48; // header + toolbar 高さ相当
      // canvas.setWidth(viewportWidth);
      // canvas.setHeight(viewportHeight - headerHeight);
      const headerHeight   = Math.ceil(headerEl.getBoundingClientRect().height);
      const toolbarHeight  = Math.ceil(toolbarEl.getBoundingClientRect().height);
      const targetHeight   = Math.max(0, viewportHeight - headerHeight - toolbarHeight);
      canvas.setWidth(viewportWidth);
      canvas.setHeight(targetHeight);

      canvas.calcOffset();
      // canvas.renderAll();
      (canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll());
    }
    window.addEventListener('resize', resizeCanvasToViewport, { passive:true });

    /** @type {{x:number,y:number}|null} 直近ポインタ位置 */
    let lastPointer = null;

    /**
     * 新規配置の左上座標（未取得時は中央）
     * @returns {{x:number,y:number}}
     */
    function getDropPoint(){
      if (lastPointer) return lastPointer;
      return { x: canvas.getWidth()/2, y: canvas.getHeight()/2 };
    }

    // ---------------- 保存スロット機能 ここから ----------------

    /** 保存スロット数 */
    const SLOT_COUNT = 10;
    /** localStorage のキー接頭辞 */
    const LS_KEY_PREFIX = 'wb_slot_v1_';
    /** 現在選択中のスロット番号（0-based） */
    let currentSlot = 0;
    /** 自動保存のデバウンス用タイマー */
    let autosaveTimer = null;

    /**
     * キャンバス状態を JSON 文字列にして返す
     * @returns {string}
     */
    function exportCanvasJSON(){
      // 追加プロパティなし（_label は復元時に再付与する）
      const json = canvas.toJSON();
      // return JSON.stringify(json);
      return JSON.stringify(json, null , 2);
    }

    /**
     * JSON 文字列からキャンバスを復元する
     * @param {string} jsonText
     * @param {() => void=} cb 復元後のコールバック
     * @returns {void}
     */
    function importCanvasJSON(jsonText, cb){
      try{
        const parsed = JSON.parse(jsonText);
        canvas.loadFromJSON(parsed, () => {
          // 復元後にグループへ _label を再アタッチ（中央ラベルを探す）
          attachGroupLabelPointers();
          // canvas.renderAll();
          canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
          canvasEl.focus({preventScroll:true});
          cb && cb();
        });
      }catch(err){
        console.error('loadFromJSON failed:', err);
      }
    }

    /**
     * すべてのグループに対して、内部の Text を _label として再設定する
     * @returns {void}
     */
    function attachGroupLabelPointers(){
      const objs = canvas.getObjects();
      for (const obj of objs){
        if (obj.type === 'group' && obj._objects){
          const label = obj._objects.find(o => o.type === 'text');
          if (label) obj._label = label;
          // 復元後に中央へ（スナップ）
          if (obj._label) centerGroupLabel(obj);
        }
      }
    }

    /**
     * 指定スロットに保存
     * @param {number} slot
     * @returns {void}
     */
    function saveToSlot(slot){
      try{
        const key = LS_KEY_PREFIX + slot;
        localStorage.setItem(key, exportCanvasJSON());
      }catch(err){
        console.error('saveToSlot failed:', err);
      }
    }

    /**
     * 指定スロットから読み込み（なければ何もしない）
     * @param {number} slot
     * @returns {void}
     */
    function loadFromSlot(slot){
      const key = LS_KEY_PREFIX + slot;
      const json = localStorage.getItem(key);
      if (!json){
        // 何も保存されていない場合はクリア
        canvas.clear();
        // canvas.setBackgroundColor('#ffffff', () => {});
        setCanvasBg('#ffffff');
        // canvas.renderAll();
        return;
      }
      importCanvasJSON(json);
    }

    function setCanvasBg(color){
      canvas.backgroundColor = color;
      (canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll());
    }

    /**
     * スロットボタンの UI を再描画
     * @returns {void}
     */
    function refreshSlotButtonsUI(){
      const btns = slotButtonsEl.querySelectorAll('.slot-btn');
      btns.forEach((btn, idx) => {
        btn.classList.toggle('active', idx === currentSlot);
      });
    }

    /**
     * 指定インデックスのスロットを選択して復元・描画する
     * @param {number} i - 0-based slot index（範囲外でもOK：内部で丸める）
     * @returns {void}
     */
    function selectSlot(i){
      // 範囲丸め
      currentSlot = ((i % SLOT_COUNT) + SLOT_COUNT) % SLOT_COUNT;
      refreshSlotButtonsUI();
      loadFromSlot(currentSlot);
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      canvasEl.focus({preventScroll:true});
      // 切り替え後の自動保存先はこのスロット
      scheduleAutosave();
    }

    /**
     * スロットボタン群を生成
     * @returns {void}
     */
    function buildSlotButtons(){
      slotButtonsEl.innerHTML = '';
      for (let i=0; i<SLOT_COUNT; i++){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'slot-btn';
        btn.textContent = String(i+1);
        btn.title = `スロット ${i+1}`;

        btn.addEventListener('click', () => selectSlot(i));

        slotButtonsEl.appendChild(btn);
      }
      refreshSlotButtonsUI();
    }

    /**
     * 自動保存をデバウンスして実行
     * @returns {void}
     */
    function scheduleAutosave(){
      if (autosaveTimer) clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(() => {
        saveToSlot(currentSlot);
      }, 300); // 0.3s 後に保存（連続操作の無駄保存を抑制）
    }

    // --- 変更イベントで自動保存（選択・移動・追加・削除・変形など） ---
    ['object:added','object:removed','object:modified','object:scaled','object:rotated','object:moved'].forEach(evtName=>{
      canvas.on(evtName, () => scheduleAutosave());
    });

    // ---------------- 保存スロット機能 ここまで ----------------

    // ====== 既存の描画・編集ロジック（あなたのコードを尊重しつつ一部整形） ======

    // マウス移動で現在位置を記録 & 線プレビュー更新
    canvas.on('mouse:move', (evt) => {
      const p = canvas.getPointer(evt.e);
      lastPointer = { x: p.x, y: p.y };
      updateLinePreviewIfNeeded();
    });

    /** 図形移動の微調整 */
    function nudgeObject(obj, dx, dy){
      obj.set({ left: (obj.left||0)+dx, top: (obj.top||0)+dy });
      obj.setCoords();
      canvas.renderAll();
    }

    /** 複製（Fabric v6 は Promise 版） */
    function duplicateObject(obj){
      obj.clone()
        .then((clone) => {
          clone.set({
            left: (obj.left || 0) + 16,
            top:  (obj.top  || 0) + 16
          });
          canvas.add(clone);
          canvas.setActiveObject(clone);
          (canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll());
        })
        .catch((err) => console.error('clone failed:', err));
    }

    /** 回転 */
    function rotateObject(obj, deg){
      const cur = obj.angle || 0;
      obj.rotate(cur + deg);
      obj.setCoords();
      canvas.renderAll();
    }

    /** グループ共通オプション */
    const groupOptions = {
      hasControls: true,
      hoverCursor: 'move',
      originX: 'left',
      originY: 'top',
      opacity: 1,
      objectCaching: false
    };

    /**
     * グループ内テキストラベル（group._label）を、図形グループの「見た目の中心」に再配置する。
     * - getBoundingRect(true, true) でグループの外接矩形（キャンバス座標）を取得
     * - その中心点を group.toLocalPoint(...) でローカル座標に変換して配置
     * @param {fabric.Group} group
     * @returns {void}
     */
    function centerGroupLabel(group){
      if (!group || !group._label) return;

      // グループの見た目の外接矩形（キャンバス座標）
      const br = group.getBoundingRect(true, true);
      const centerCanvas = new fabric.Point(
        br.left + br.width / 2,
        br.top  + br.height / 2
      );

      // キャンバス座標 → グループのローカル座標へ変換
      // const centerLocal = group.toLocalPoint(centerCanvas, 'left', 'top');
      // ★ v6 互換：キャンバス座標 → グループローカル座標を行列で求める
      //   object->canvas 変換行列を逆行列にして、キャンバス点に適用
      const m  = group.calcTransformMatrix();                  // Object -> Canvas
      const im = fabric.util.invertTransform(m);               // Canvas -> Object
      const centerLocal = fabric.util.transformPoint(centerCanvas, im);

      // ラベルを中央へ（中央基準で配置）
      group._label.set({
        originX: 'center',
        originY: 'center',
        left: centerLocal.x,
        top:  centerLocal.y,
        textAlign: 'center'
      });

      // Debug
      console.log('[DBG] label after', {
        localX: centerLocal.x,
        localY: centerLocal.y,
        groupAngle: group.angle,
        scaleX: group.scaleX, scaleY: group.scaleY
      });

      group.setCoords();

      // Debug
      console.log('[DBG] label after:', { left: group._label.left, top: group._label.top, originX: group._label.originX, originY: group._label.originY });
    }

    /** 図形+ラベルのグループを作成して追加 */
    function createLabeledGroup(baseObjects){
      const dropPoint = getDropPoint();

      const labelText = new fabric.Text('', {
        fontSize: 16, 
        fill: '#0f172a',
        originX:'center', 
        originY:'center',
        top:0, 
        left:0, 
        textAlign:'center',
        opacity:1, 
        objectCaching:false
      });
      // 子図形にも可視パラメータを念のため付与
      baseObjects.forEach(o => o.set({ opacity:1, objectCaching:false, globalCompositeOperation:'source-over' }));

      const group = new fabric.Group([...baseObjects, labelText], {
        ...groupOptions, 
        left: dropPoint.x, 
        top: dropPoint.y,
        globalCompositeOperation:'source-over'
      });
      group._label = labelText;
      canvas.add(group);

      // // ※ ここはあなたの現状のロジックに合わせて必要なら中央化
      // labelText.set({ left: group.width/2, top: group.height/2 });
      // 見た目の中心に確実に配置（スケール・回転の影響を受けても中央）
      centerGroupLabel(group);

      canvas.setActiveObject(group);
      group.setCoords();
      // 最前面に出して確実に描画
      // canvas.renderAll();
      if (canvas.bringToFront) canvas.bringToFront(group);
      (canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll());

      return group;
    }

    /** 図形ファクトリ */
    function addCircle(){
      const circle = new fabric.Circle({
        left:0, top:0, radius:60,
        fill:'#22c55e', stroke:'#052e16', strokeWidth:3, strokeUniform:true
      });
      createLabeledGroup([circle]);
    }
    function addRect(){
      const rect = new fabric.Rect({
        left:0, top:0, width:150, height:100, rx:8, ry:8,
        fill:'#60a5fa', stroke:'#0a2472', strokeWidth:3, strokeUniform:true
      });
      createLabeledGroup([rect]);

      // console.log("-------- debug -------");
      // console.log(canvas.getWidth());
      // console.log(canvas.getHeight());
      // console.log(canvas.getObjects().map(o => ({type:o.type, visible:o.visible, opacity:o.opacity})));
    }

    // function addTextBox(){
    //   const box = new fabric.Rect({
    //     left:0, top:0, width:200, height:80, rx:10, ry:10,
    //     fill:'#f59e0b', stroke:'#7a3d00', strokeWidth:3, strokeUniform:true
    //   });
    //   createLabeledGroup([box]);
    // }

    function addTextBox(){
      const drop = getDropPoint();
      // 枠なし・背景なし・空文字の Textbox をそのまま配置
      const tb = new fabric.Textbox('', {
        left: drop.x, top: drop.y,
        fontSize: 18,
        fill: '#0f172a',
        backgroundColor: '', // 透明
        textAlign: 'left',
        objectCaching: false
      });
      canvas.add(tb);
      canvas.setActiveObject(tb);
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
    }

    /** 任意オブジェクト群をグループ化して追加（線＋矢印ヘッド用） */
    function addGroup(objects) {
      const group = new fabric.Group([...objects], { ...groupOptions });
      canvas.add(group);
      canvas.setActiveObject(group);
      group.setCoords();
      canvas.renderAll();
      return group;
    }

    /** 色ローテーション */
    function cycleFillColor(obj){
      let target = obj;
      if (obj.type === 'group' && obj._objects && obj._objects.length){
        const shape = obj._objects.find(
          o => o.type === 'rect' || o.type === 'circle' || o.type === 'triangle' || o.type === 'line' || o.type === 'path'
        );
        if (shape) target = shape;
      }
      const current = (target.fill || color_palette[0]).toString();
      const idx = color_palette.indexOf(current);
      const next = color_palette[(idx + 1 + color_palette.length) % color_palette.length];
      target.set({ fill: next });
      canvas.renderAll();
    }

    /** ダブルクリック/Enter でラベル編集 */
    function editLabelByDblClick(targetObject){
      if (!targetObject) return;
      // グループ or 単体テキストの両方に対応
      const group = (targetObject.type === 'group') ? targetObject : targetObject.group;
      const isTextOnly = (targetObject.type === 'textbox' || targetObject.type === 'text');
      let labelText = null;

      if (group){
        labelText = group._label || (group._objects ? group._objects.find(o=>o.type==='text') : null);
        if (!labelText) return;
      }else if (isTextOnly){
        labelText = targetObject; // 単体テキストを直接編集
      }else{
        return;
      }

      const currentText = labelText.text || '';
      const nextText = window.prompt('図形のテキストを入力してください：', currentText);
      if (nextText === null) return;

      // --- debug: 編集直前の各種座標 ---
      if (group){
        const br = group.getBoundingRect(true, true);
        console.log('[DBG] group aabb (canvas):', br);
        console.log('[DBG] group w/h/local:', group.width, group.height, 'angle=', group.angle, 'scale=', group.scaleX, group.scaleY);
        console.log('[DBG] label before:', { left: labelText.left, top: labelText.top, originX: labelText.originX, originY: labelText.originY });
      }

      labelText.set({ text: nextText, textAlign:'center', originX:'center', originY:'center' });
      // // ★グループのときは必ず中央に再配置（ローカル座標の中心）
      // if (group){
      //   labelText.set({ left: group.width/2, top: group.height/2 });
      // }
      // ★グループのときは見た目の中心に再配置（回転・拡大縮小後もずれない）
      if (group){
        centerGroupLabel(group);
      }

      (group || labelText).setCoords();
      canvas.renderAll();
    }




    // ===== 線描画（aキー → プレビュー → クリックで確定） =====
    let pendingLineStart = null;            // 始点
    let previewLine = null;                 // プレビュー線
    let previewLineArrowHead = null;        // プレビュー矢印ヘッド

    function startLineDrawing(){
      const start = getDropPoint();
      pendingLineStart = { x: start.x, y: start.y };

      if (previewLine) { canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead) { canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }

      previewLine = new fabric.Line([start.x, start.y, start.x, start.y],{
        stroke:'#111827', strokeWidth:2, strokeLineCap:'round',
        opacity:.6, selectable:false, evented:false, strokeDashArray:[6,6]
      });
      previewLineArrowHead = new fabric.Triangle({
        left:start.x, top:start.y, width:32, height:32, angle:0,
        fill:'black', stroke:'black', strokeWidth:2, originX:'center', originY:'center',
        selectable:false, evented:false
      });

      canvas.add(previewLine, previewLineArrowHead);
      canvas.bringToFront && canvas.bringToFront(previewLine);
      canvas.renderAll();
    }

    function updateLinePreviewIfNeeded(){
      if (!pendingLineStart || !previewLine) return;
      const pos = getDropPoint();
      previewLine.set({ x2: pos.x, y2: pos.y });
      // 矢印位置
      if (previewLineArrowHead){
        previewLineArrowHead.set({ left:pos.x, top:pos.y });
        // 角度計算（簡易）
        const dx = pos.x - previewLine.x1;
        const dy = pos.y - previewLine.y1;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        previewLineArrowHead.set({ angle: angle + 90 });
      }
      previewLine.setCoords();
      previewLineArrowHead && previewLineArrowHead.setCoords();
      canvas.renderAll();
    }

    function finalizeLineDrawingIfNeeded(domEvent){
      if (!pendingLineStart) return false;
      const p = canvas.getPointer(domEvent);
      const endX = p.x, endY = p.y;

      const line = new fabric.Line([pendingLineStart.x, pendingLineStart.y, endX, endY],{
        stroke:'#111827', strokeWidth:3, strokeLineCap:'round', selectable:true
      });

      canvas.add(line);
      if (previewLineArrowHead){
        addGroup([line, previewLineArrowHead]);
      }

      // プレビューを消して状態クリア
      if (previewLine){ canvas.remove(previewLine); previewLine = null; }
      previewLineArrowHead = null;
      pendingLineStart = null;

      canvas.renderAll();
      scheduleAutosave(); // 追加直後を保存
      return true;
    }

    function cancelLinePreview(render){
      if (previewLine){ canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead){ canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }
      pendingLineStart = null;
      if (render) canvas.renderAll();
    }

    // ====== イベント登録 ======
    canvas.upperCanvasEl.addEventListener('dblclick', (domEvt) => {
      const target = canvas.findTarget(domEvt, true);
      if (!target) return;
      editLabelByDblClick(target);
    });

    canvas.on('mouse:down', (evt) => {
      const finalized = finalizeLineDrawingIfNeeded(evt.e);
      if (finalized) return;
      if (!evt.target){
        canvas.discardActiveObject();
        canvas.renderAll();
      }
    });

    /**
     * 選択オブジェクトを取得
     * @returns {fabric.Object|null}
     */
    function getActiveObject(){
      const active = canvas.getActiveObject();
      return active || null;
    }

    /**
     * キー押下ハンドラ
     * @param {KeyboardEvent} ev
     * @returns {void}
     */
    function handleKeydown(ev){
      const tag = (document.activeElement && document.activeElement.tagName) || '';
      if (tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT') return;
      if (ev.isComposing || ev.repeat) return;

      const keyLower = (ev.key || '').toLowerCase();
      const code = ev.code || '';
      const active = getActiveObject();

      // 追加
      if (keyLower==='c' || code==='KeyC'){ ev.preventDefault(); addCircle(); scheduleAutosave(); return; }
      if (keyLower==='s' || code==='KeyS'){ ev.preventDefault(); addRect();   scheduleAutosave(); return; }
      if (keyLower==='t' || code==='KeyT'){ ev.preventDefault(); addTextBox(); scheduleAutosave(); return; }

      // 線（a）
      if (keyLower==='a' || code==='KeyA'){ ev.preventDefault(); startLineDrawing(); return; }
      if (keyLower==='escape' || code==='Escape'){ ev.preventDefault(); cancelLinePreview(true); return; }

      if (!active) return;

      // 移動（矢印）
      const step = ev.shiftKey ? 10 : 1;
      if (keyLower==='arrowup'){ ev.preventDefault(); nudgeObject(active,0,-step); scheduleAutosave(); return; }
      if (keyLower==='arrowdown'){ ev.preventDefault(); nudgeObject(active,0, step); scheduleAutosave(); return; }
      if (keyLower==='arrowleft'){ ev.preventDefault(); nudgeObject(active,-step,0); scheduleAutosave(); return; }
      if (keyLower==='arrowright'){ ev.preventDefault(); nudgeObject(active, step,0); scheduleAutosave(); return; }

      // 削除
      if (keyLower==='delete' || keyLower==='backspace'){
        ev.preventDefault();
        canvas.remove(active);
        canvas.discardActiveObject();
        canvas.renderAll();
        scheduleAutosave();
        return;
      }

      // 複製
      if ((ev.ctrlKey || ev.metaKey) && keyLower==='d'){
        ev.preventDefault();
        duplicateObject(active);
        scheduleAutosave();
        return;
      }

      // 削除
      if (keyLower==='d'){
        ev.preventDefault();
        canvas.remove(active);
        canvas.discardActiveObject();
        canvas.renderAll();
        scheduleAutosave();
        return;
      }

      // Enter: テキスト編集
      if (keyLower==='enter' || code==='Enter'){
        ev.preventDefault();
        editLabelByDblClick(active);
        scheduleAutosave();
        return;
      }

      // Space: 色ローテーション
      if (keyLower===' ' || keyLower==='spacebar' || code==='Space'){
        ev.preventDefault();
        cycleFillColor(active);
        scheduleAutosave();
        return;
      }

      // 回転/スケールなど（必要なら追加）
      if (keyLower==='r'){ ev.preventDefault(); rotateObject(active, ev.shiftKey ? -15 : 15); scheduleAutosave(); return; }
      if (keyLower==='+'){ ev.preventDefault(); active.set({ scaleX:(active.scaleX||1)* (ev.shiftKey?1.25:1.1), scaleY:(active.scaleY||1)* (ev.shiftKey?1.25:1.1) }); active.setCoords(); canvas.renderAll(); scheduleAutosave(); return; }
      if (keyLower==='-'){ ev.preventDefault(); active.set({ scaleX:(active.scaleX||1)* (ev.shiftKey?0.8:0.9), scaleY:(active.scaleY||1)* (ev.shiftKey?0.8:0.9) });  active.setCoords(); canvas.renderAll(); scheduleAutosave(); return; }
    }
    window.addEventListener('keydown', handleKeydown, true);

    // クリックでフォーカス
    document.addEventListener('pointerdown', () => { canvasEl.focus({preventScroll:true}); });

    // Shift + ホイールでスロット切替（上：前へ／下：次へ）
    canvas.upperCanvasEl.addEventListener('wheel', (e) => {
      if (!e.shiftKey) return;      // Shift が押されている時だけ
      e.preventDefault();           // ページスクロールを防止
      const dir = e.deltaY > 0 ? 1 : -1;  // 下回し=次 / 上回し=前
      selectSlot(currentSlot + dir);
    }, { passive: false });

    // クリアボタン
    clearBtn.addEventListener('click', () => {
      const ok = window.confirm(`スロット ${currentSlot + 1} の全オブジェクトを削除します。\nこの操作は元に戻せません。よろしいですか？`);
      if (!ok) return;
      // 全削除 → 背景を白に戻す → 保存
      canvas.clear();
      setCanvasBg('#ffffff');
      saveToSlot(currentSlot);
    });

    // JSONインポート（選択中スロットを全削除→インポート→自動保存）
    importBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/json';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try{
            // 既存を破棄してから読み込み
            canvas.clear();
            setCanvasBg('#ffffff');
            importCanvasJSON(String(reader.result), () => {
              // スロットにも保存
              saveToSlot(currentSlot);
            });
          }catch(e){
            console.error('import failed:', e);
          }
        };
        reader.readAsText(file);
      };
      input.click();
    });

    // --- エクスポートボタン（JSON ダウンロード） ---
    exportBtn.addEventListener('click', () => {
      const json = exportCanvasJSON();
      const blob = new Blob([json], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `canvas-export-slot${currentSlot+1}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // --- 初期化：スロットボタン作成 → Canvas サイズ調整 → 起動時にスロット1を復元 ---
    buildSlotButtons();
    resizeCanvasToViewport();
    currentSlot = 0;
    refreshSlotButtonsUI();
    loadFromSlot(currentSlot);   // ページを開いたら一番先頭のスロットを自動復元
    canvasEl.focus({preventScroll:true});
  })();
  </script>



</body>
</html>
