<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Fabric.js 図形作成ツール（保守性向上版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --fg:#0f172a;
      --line:#3a3c44;
      --slotBg:#f5f7fb;
      --slotSel:#0ea5e9;
      --slotTxt:#0b1323;
      --slotEmptyBg:#f1f5f9;
      --slotEmptyTxt:#94a3b8;
      /* データあり（淡いオレンジ） */
      --slotHasBg:#fff1e6;
      --slotHasBorder:#f59e0b;
      --slotHasTxt:#9a3412;
    }
    html,body{height:100%;margin:0;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"ヒラギノ角ゴ ProN",Meiryo,sans-serif;}
    header{padding:10px 14px;border-bottom:1px solid var(--line);display:flex;gap:18px;align-items:center;flex-wrap:wrap;}
    .kbd{padding:.2em .45em;border:1px solid var(--line);border-bottom-width:2px;border-radius:6px;font-weight:600;background:#f2f3f5;}
    #wrap{height:calc(100% - 104px);}
    #stage{display:block;outline:none;background:#fff;}
    .upper-canvas{background: transparent !important;}

    /* ツールバー */
    #toolbar{display:flex;align-items:center;gap:10px;padding:8px 14px;border-bottom:1px solid var(--line);background:#fafbff;flex-wrap:wrap;}
    .slot-btn{
      min-width:38px;padding:6px 10px;border:1px solid #cfd6e3;border-radius:8px;
      background:var(--slotBg);color:var(--slotTxt);font-weight:600;cursor:pointer;user-select:none;position:relative;
      transition:background .15s ease,border-color .15s ease,color .15s ease;
    }
    .slot-btn.active{
      border-color:var(--slotSel);box-shadow:0 0 0 2px rgba(14,165,233,.2) inset;color:var(--slotSel);background:#e8f6fd;
    }
    .slot-btn.empty{
      background:var(--slotEmptyBg);color:var(--slotEmptyTxt);border-style:dashed;
    }
    .slot-btn.hasdata{
      background:var(--slotHasBg);border-color:var(--slotHasBorder);color:var(--slotHasTxt);
    }
    .toolbar-button{padding:6px 12px;border:1px solid #cfd6e3;border-radius:8px;background:#ffffff;font-weight:600;cursor:pointer;}
    .toolbar-button:hover{background:#f6f8fc;}
    .spacer{flex:1 1 auto;}

    /* スロットサムネプレビュー */
    #slotPreview{
      position:fixed;left:0;top:0;transform: translate(12px, 12px);
      display:none;z-index:9999;background:#fff;border:1px solid rgba(0,0,0,.12);
      box-shadow:0 10px 24px rgba(2,6,23,.15);border-radius:10px;padding:6px;pointer-events:none;
    }
    #slotPreview img{display:block;max-width:420px;max-height:270px;}
    #slotPreview .caption{font-size:12px;color:#475569;margin-top:4px;text-align:center;}
  </style>
</head>
<body>
  <header id="header">
    <div>
      <span class="kbd">c</span> 円 /
      <span class="kbd">s</span> 四角 /
      <span class="kbd">t</span> テキスト /
      <span class="kbd">a</span> 線
    </div>
    <div>
      <span class="kbd">Ctrl|⌘ + Z</span> Undo /
      <span class="kbd">Ctrl|⌘ + Shift + Z</span> Redo /
      <span class="kbd">Ctrl|⌘ + A</span> すべて選択 /
      <span class="kbd">d</span> 選択削除
    </div>
  </header>

  <div id="toolbar" aria-label="保存スロットとエクスポート">
    <div id="slotButtons"></div>
    <div class="spacer"></div>
    <button id="imageBtn" class="toolbar-button" type="button">画像挿入</button>
    <button id="pngBtn" class="toolbar-button" type="button">PNG出力</button>
    <button id="importBtn" class="toolbar-button" type="button">JSONインポート</button>
    <button id="exportBtn" class="toolbar-button" type="button">JSONエクスポート</button>
    <button id="titleBtn" class="toolbar-button" type="button">タイトル変更</button>
    <button id="clearBtn" class="toolbar-button" type="button">クリア</button>
  </div>

  <div id="wrap">
    <canvas id="stage" tabindex="0" aria-label="図形キャンバス"></canvas>
  </div>

  <div id="slotPreview" aria-hidden="true">
    <img alt="slot preview" />
    <div class="caption"></div>
  </div>

  <!-- Fabric.js v6.7.1 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/671/index.min.js"></script>
  <script>
  (function(){
    // =========================
    // 開発支援用ログ
    // =========================
    const DEBUG = false;
    const D = (...a) => DEBUG && console.log('[dbg]', ...a);

    // =========================
    // 共通定数（“魔法数”の排除）
    // =========================
    // プレビュー画像サイズ
    const PREVIEW_W = 420;
    const PREVIEW_H = 270;
    // サムネイルの外接矩形フィット用パディング
    const FIT_PAD = 12;
    // 更新日バッジの描画スタイル
    const BADGE_FONT = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    const BADGE_PAD_X = 8;
    const BADGE_PAD_Y = 6;
    const BADGE_RADIUS = 8;
    const BADGE_MARGIN = 8;
    const BADGE_BG = 'rgba(255,255,255,0.92)';
    const BADGE_BORDER = 'rgba(0,0,0,0.15)';
    const BADGE_TEXT = '#334155';
    // スロット数
    const SLOT_COUNT = 20;
    // LocalStorage キー
    const LS_KEY_PREFIX = 'wb_slot_v1_';
    const LS_KEY_META_PREFIX = 'wb_slot_v1_meta_';
    // スロットタイトル保存用
    const LS_KEY_TITLE_PREFIX = 'wb_slot_title_v1_';
    // オートセーブ
    const AUTOSAVE_DELAY = 300;
    // ズーム制御
    const ZOOM_MIN = 0.2;
    const ZOOM_MAX = 5;
    const ZOOM_WHEEL_FACTOR = 0.999;
    // Undo/Redo 履歴件数
    const HISTORY_LIMIT = 50;

    // =========================
    // DOM 参照
    // =========================
    const canvasEl = document.getElementById('stage');
    const headerEl = document.getElementById('header');
    const toolbarEl = document.getElementById('toolbar');
    const slotButtonsEl = document.getElementById('slotButtons');
    const exportBtn = document.getElementById('exportBtn');
    const imageBtn  = document.getElementById('imageBtn');
    const importBtn = document.getElementById('importBtn');
    const clearBtn  = document.getElementById('clearBtn');
    const titleBtn  = document.getElementById('titleBtn');
    const pngBtn    = document.getElementById('pngBtn');
    const slotPreviewEl = document.getElementById('slotPreview');
    const slotPreviewImg = slotPreviewEl.querySelector('img');
    const slotPreviewCaption = slotPreviewEl.querySelector('.caption');

    // =========================
    // Fabric Canvas 初期化
    // =========================
    const canvas = new fabric.Canvas(canvasEl, {
      backgroundColor: '#ffffff',
      selection: true,
      preserveObjectStacking: true
    });

    /**
     * Fabric のグリップ/枠線の見た目を初期設定する。
     * 引数/戻り値なし（副作用：fabric.Object.prototype を変更）
     */
    // ---- 選択ハンドルのテーマ設定 ----
    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.cornerColor = '#0ea5e9';
    fabric.Object.prototype.cornerStyle = 'rect';
    fabric.Object.prototype.cornerSize = 10;
    fabric.Object.prototype.borderColor = '#0ea5e9';

    // カラーパレット
    const color_palette = ['#60a5fa','#22c55e','#f59e0b','#ef4444','#a78bfa', '#ffffff', '#000000'];

    // 図形作成時の既定パラメータ
    const line_param = { stroke:'#111827', strokeWidth:3, strokeLineCap:'round' };
    const arrow_param = { width:32, height:32, fill:'#111827', stroke:'#111827', strokeWidth:2, originX:'center', originY:'center' };

    /**
     * ビューポートに合わせて Canvas のピクセルサイズを追従させる。
     * 引数なし / 戻り値なし（canvas に副作用）
     */
    function resizeCanvasToViewport(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const hh = Math.ceil(headerEl.getBoundingClientRect().height);
      const th = Math.ceil(toolbarEl.getBoundingClientRect().height);
      // ---- レイアウト計算 ----
      canvas.setWidth(vw);
      const usableHeight = Math.max(0, vh - hh - th);
      canvas.setHeight(usableHeight);
      canvas.calcOffset();
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }
    window.addEventListener('resize', resizeCanvasToViewport, { passive:true });

    let lastPointer = null;
    /**
     * 直近のマウス位置（なければキャンバス中央）を返す。
     * @returns {{x:number,y:number}} ドロップ配置の基準点
     */
    function getDropPoint(){
      if (lastPointer) return lastPointer;
      return { x: canvas.getWidth()/2, y: canvas.getHeight()/2 };
    }

    // =========================
    // スロット機能
    // =========================
    // ※ 視点メタデータ（ズーム/右上ワールド座標/updatedAt）は LS_KEY_META_PREFIX に保存
    let currentSlot = 0;
    let autosaveTimer = null;

    /**
     * 現在のキャンバス内容を Fabric JSON 文字列として返す。
     * @returns {string} JSON 文字列
     */
    function exportCanvasJSON(){
      const json = canvas.toJSON();
      return JSON.stringify(json, null, 2);
    }
    /**
     * Fabric JSON 文字列を読み込み、キャンバスへ反映する。
     * @param {string} jsonText - Fabric JSON 文字列
     * @param {Function} [cb] - 読み込み完了後に呼ばれるコールバック
     * @returns {void}
     */
    function importCanvasJSON(jsonText, cb){
      try{
        const parsed = JSON.parse(jsonText);
        canvas.loadFromJSON(parsed, () => {
          attachGroupLabelPointers();
          const render = canvas.requestRenderAll || canvas.renderAll;
          render.call(canvas);
          canvasEl.focus({preventScroll:true});
          cb && cb();
        });
      }catch(err){ console.error('loadFromJSON failed:', err); }
    }
    /**
     * グループ内のラベル(Text)への参照を付与し、中央へ配置し直す。
     * @returns {void}
     */
    function attachGroupLabelPointers(){
      for (const obj of canvas.getObjects()){
        if (obj.type === 'group' && obj._objects){
          const label = obj._objects.find(o => o.type === 'text');
          if (label) obj._label = label;
          if (obj._label) centerGroupLabel(obj);
        }
      }
    }
    /**
     * 現在のスロットへキャンバス JSON を保存し、視点メタも保存する。
     * （updatedAt は編集時のみ更新。ズーム時は更新しない）
     * @param {number} slot - 保存先スロット番号
     */
    function saveToSlot(slot){
      try{
        const key = LS_KEY_PREFIX + slot;
        localStorage.setItem(key, exportCanvasJSON());
        // ---- 視点メタも一緒に保存（最終更新日時は編集時のみ更新）----
        saveViewportMeta(slot);
        refreshSlotButtonsUI();
      }catch(err){ console.error('saveToSlot failed:', err); }
    }
    /**
     * スロットからキャンバス JSON を読み込み、視点メタを復元する。
     * @param {number} slot - 読み込み元スロット番号
     */
    function loadFromSlot(slot){
      const key = LS_KEY_PREFIX + slot;
      const json = localStorage.getItem(key);
      if (!json){
        canvas.clear();
        setCanvasBg('#ffffff');
        return;
      }
      importCanvasJSON(json, () => {
        // ---- 視点メタを復元（あれば）----
        applyViewportFromMeta(slot);
      });
    }
    /**
     * キャンバス背景色を設定して再描画。
     * @param {string} color - CSS 色
     */
    function setCanvasBg(color){
      canvas.backgroundColor = color;
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }

    /**
     * スロットタイトル取得
     * @param {number} slot
     * @returns {string|null} 空文字は有効なタイトル、未設定は null
     */
    function getSlotTitle(slot){
      const v = localStorage.getItem(LS_KEY_TITLE_PREFIX + slot);
      return (v === null) ? null : v;
    }
    /**
     * スロットタイトル設定（空文字可）
     * @param {number} slot
     * @param {string} title
     */
    function setSlotTitle(slot, title){
      if (title === null || title === undefined) return;
      localStorage.setItem(LS_KEY_TITLE_PREFIX + slot, String(title));
    }
    function clearSlotTitle(slot){ localStorage.removeItem(LS_KEY_TITLE_PREFIX + slot); }

    /**
     * 指定スロットにオブジェクトが1つ以上あるか判定する。
     * @param {number} i - スロット番号
     * @returns {boolean} true: データあり / false: 空
     */
    function slotHasData(i){
      const storage_data = localStorage.getItem(LS_KEY_PREFIX + i);
      if (!!storage_data) {
        const parsed = JSON.parse(storage_data);
        return (parsed.objects.length !== 0);
      }
      return false;
    }

    // =========================
    // ビューポート保存/復元ユーティリティ
    // =========================
    /**
     * 画面上の (screenX, screenY) に対応するワールド座標を取得する。
     * @param {number} screenX
     * @param {number} screenY
     * @returns {{x:number,y:number}}
     */
    function getWorldPointAtScreen(screenX, screenY){
      const vt = canvas.viewportTransform || [1,0,0,1,0,0];
      const inv = fabric.util.invertTransform(vt);
      const p = fabric.util.transformPoint(new fabric.Point(screenX, screenY), inv);
      return { x: p.x, y: p.y };
    }
    /**
     * 現在のズームと「画面右上に来ているワールド座標」を保存する。
     * options.touchUpdatedAt === false の時は updatedAt を変更しない（ズーム操作時など）
     * @param {number} slot - 保存先スロット番号
     * @param {{touchUpdatedAt?:boolean}} [options]
     * @returns {void}
     */
    function saveViewportMeta(slot, { touchUpdatedAt = true } = {}){
      try{
        const zoom = canvas.getZoom();
        // ---- 右上は (canvas.width, 0) のスクリーン座標 ----
        const viewTR = getWorldPointAtScreen(canvas.getWidth(), 0);
        // 既存の updatedAt を引き継ぐ（touchUpdatedAt=false の場合）
        let prevUpdated = null;
        try {
          const prevRaw = localStorage.getItem(LS_KEY_META_PREFIX + slot);
          if (prevRaw) prevUpdated = (JSON.parse(prevRaw).updatedAt || null);
        } catch(_){}
        const updatedAt = touchUpdatedAt ? new Date().toISOString() : prevUpdated;
        const meta = { zoom, viewTR, updatedAt };
        localStorage.setItem(LS_KEY_META_PREFIX + slot, JSON.stringify(meta));
      }catch(e){ console.warn('saveViewportMeta failed:', e); }
    }
    /**
     * 保存済みの視点メタを取得する。
     * @param {number} slot
     * @returns {{zoom:number, viewTR:{x:number,y:number}, updatedAt?:string}|null}
     */
    function readViewportMeta(slot){
      try{
        const raw = localStorage.getItem(LS_KEY_META_PREFIX + slot);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed.zoom !== 'number' || !parsed.viewTR) return null;
        return parsed;
      }catch(e){ return null; }
    }
    /**
     * メタ情報に基づき viewportTransform を再設定する。
     * @param {number} slot
     * @returns {void}
     */
    function applyViewportFromMeta(slot){
      const meta = readViewportMeta(slot);
      if (!meta) return;
      const z = meta.zoom;
      if (!z || z <= 0) return;
      const vx = meta.viewTR?.x ?? 0;
      const vy = meta.viewTR?.y ?? 0;
      // 右上 (screenW, 0) が (vx, vy) に一致するように
      const e = canvas.getWidth() - z * vx;
      const f = 0 - z * vy;
      canvas.setViewportTransform([ z, 0, 0, z, e, f ]);
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }

    /** スロットボタンの状態をデータ有無や選択中で更新する。 */
    function refreshSlotButtonsUI(){
      const btns = slotButtonsEl.querySelectorAll('.slot-btn');
      btns.forEach((btn, idx) => {
        const has = slotHasData(idx);
        btn.classList.toggle('active', idx === currentSlot);
        btn.classList.toggle('empty', !has);
        btn.classList.toggle('hasdata', has);
      });
    }

    /**
     * スロットを選択し、内容と視点を読み込む。
     * @param {number} i - スロット番号
     */
    function selectSlot(i){
      currentSlot = Math.max(0, Math.min(SLOT_COUNT-1, i));
      refreshSlotButtonsUI();
      applyingHistory = true;
      loadFromSlot(currentSlot);
      applyingHistory = false;
      resetHistoryBaseline();
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
      canvasEl.focus({preventScroll:true});
    }

    // タイトル変更ボタン
    titleBtn.addEventListener('click', () => {
      const cur = getSlotTitle(currentSlot);
      const input = window.prompt(`スロット${currentSlot+1} のタイトルを入力（空で無題）:`, cur ?? '');
      if (input === null) return; // キャンセル
      setSlotTitle(currentSlot, input); // 空文字も許可
      refreshSlotButtonsUI(); //（ボタン表示にタイトルは使っていないが将来拡張に備え）
      if (hoveredSlot === currentSlot && slotPreviewEl.style.display === 'block') showSlotPreview(currentSlot, lastHoverEvent);
    });

    /**
     * スロットボタンを生成し、クリック/プレビューのイベントを付与する。
     */
    function buildSlotButtons(){
      slotButtonsEl.innerHTML = '';
      for (let i=0; i<SLOT_COUNT; i++){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'slot-btn';
        btn.textContent = String(i+1);
        btn.title = `スロット ${i+1}`;
        btn.dataset.slot = String(i);

        btn.addEventListener('click', () => selectSlot(i));

        // Shift+ホバー プレビュー
        btn.addEventListener('pointerenter', (e) => {
          hoveredSlot = i; lastHoverEvent = e;
          if (e.shiftKey) showSlotPreview(i, e); else hideSlotPreview();
        });
        btn.addEventListener('pointermove', (e) => {
          hoveredSlot = i; lastHoverEvent = e;
          if (e.shiftKey) showSlotPreview(i, e); else hideSlotPreview();
        });
        btn.addEventListener('pointerleave', () => { hoveredSlot = null; hideSlotPreview(); });

        slotButtonsEl.appendChild(btn);
      }
      refreshSlotButtonsUI();
    }

    /**
     * オートセーブを遅延実行でスケジュールする。
     */
    function scheduleAutosave(){
      clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(() => {
        saveToSlot(currentSlot);
      }, AUTOSAVE_DELAY);
    }

    // =========================
    // 変更イベント → 自動保存 & 履歴
    // =========================
    ['object:modified','object:scaled','object:rotated','object:moved'].forEach(evt=>{
      canvas.on(evt, () => { scheduleAutosave(); pushHistoryDebounced(); });
    });

    // =========================
    // Undo / Redo
    // =========================
    const historyStack = [];
    const redoStack = [];
    let applyingHistory = false;
    let historyTimer = null;

    /**
     * 現在のキャンバス状態スナップショット（JSON文字列）を取得。
     * @returns {string}
     */
    function getCanvasSnapshot(){ return exportCanvasJSON(); }
    /**
     * スナップショットをキャンバスへ適用する。
     * @param {string} json - JSON 文字列
     */
    function applySnapshot(json){
      applyingHistory = true;
      canvas.clear();
      setCanvasBg('#ffffff');
      importCanvasJSON(json, () => {
        applyingHistory = false;
        const render = canvas.requestRenderAll || canvas.renderAll;
        render.call(canvas);
      });
    }
    /** 履歴に現在スナップショットを積む（重複は抑止） */
    function pushHistory(){
      if (applyingHistory) return;
      const snap = getCanvasSnapshot();
      if (historyStack.length && historyStack[historyStack.length-1] === snap) return;
      historyStack.push(snap);
      if (historyStack.length > HISTORY_LIMIT) historyStack.shift();
      redoStack.length = 0;
    }
    /** 短時間の改変を 1 つにまとめるためのデバウンス push */
    function pushHistoryDebounced(){
      if (applyingHistory) return;
      clearTimeout(historyTimer);
      historyTimer = setTimeout(() => pushHistory(), 200);
    }

    /**
     * 履歴のベースラインを再作成する。
     * - undo/redo スタックをクリア
     * - 現在状態のスナップショットを 1 件だけ積む
     * @returns {void}
     */
    function resetHistoryBaseline(){
      // 既存の履歴を破棄
      historyStack.length = 0;
      redoStack.length = 0;
      pushHistory(); // 現在の状態をベースラインとして登録
    }

    /** Undo 操作 */
    function undo(){
      if (historyStack.length <= 1) return;
      const cur = historyStack.pop();
      const prev = historyStack[historyStack.length-1];
      redoStack.push(cur);
      applySnapshot(prev);
    }
    /** Redo 操作 */
    function redo(){
      if (!redoStack.length) return;
      const next = redoStack.pop();
      historyStack.push(next);
      applySnapshot(next);
    }

    // =========================
    // サムネプレビュー
    // =========================
    const slotThumbCache = new Map(); // cacheKey(slotIndex|updatedAt) -> dataURL
    let hoveredSlot = null;
    let lastHoverEvent = null;
    let shiftHeld = false;

    /** スロットボタン上に表示するプレビューを消去 */
    function hideSlotPreview(){
      slotPreviewEl.style.display = 'none';
      // 古いサムネが残るのを防止
      slotPreviewImg.removeAttribute('src');
    }
    /**
     * プレビューの表示位置をマウス座標に合わせて更新する。
     * @param {PointerEvent|MouseEvent} e
     */
    function positionSlotPreview(e){
      if (!e) return;
      slotPreviewEl.style.left = e.clientX + 'px';
      slotPreviewEl.style.top  = e.clientY + 'px';
    }

    // Shift “後押し”にも対応
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Shift'){ shiftHeld = true; if (hoveredSlot!==null) showSlotPreview(hoveredSlot, lastHoverEvent||e); }
    }, true);
    window.addEventListener('keyup', (e) => {
      if (e.key === 'Shift'){ shiftHeld = false; hideSlotPreview(); }
    }, true);

    /**
     * スロットボタン上のプレビューを表示する。
     * - サムネはキャッシュ（slotIndex|updatedAt）を利用
     * - 未キャッシュ時は生成してから表示
     * @param {number} slotIndex
     * @param {PointerEvent|MouseEvent} e
     */
    function showSlotPreview(slotIndex, e){
      if (!slotHasData(slotIndex)) { hideSlotPreview(); return; }

      // ここで枠を先に出す（画像は未セットのまま）
      positionSlotPreview(e);
      // タイトル取得（null=未設定, ""=無題）
      const t = getSlotTitle(slotIndex);
      if (t === null){
        slotPreviewCaption.textContent = `スロット ${slotIndex+1}`;
      }else{
        slotPreviewCaption.textContent = t === '' ? `スロット ${slotIndex+1}` : t;
      }
      slotPreviewImg.removeAttribute('src'); // 古い残像を消す
      slotPreviewEl.style.display = 'block';

      // 保存データとメタ（更新日時）を取得
      const json = localStorage.getItem(LS_KEY_PREFIX + slotIndex);
      const metaRaw = localStorage.getItem(LS_KEY_META_PREFIX + slotIndex);
      let updatedAt = null;
      try { updatedAt = metaRaw ? (JSON.parse(metaRaw).updatedAt || null) : null; } catch(_){}
      const cacheKey = `${slotIndex}|${updatedAt || 'none'}`;

      // ---- キャッシュがあれば即表示 ----
      const cached = slotThumbCache.get(cacheKey);
      if (cached){
        slotPreviewImg.src = cached;
        return; // 既に枠は表示済み
      }
      if (!json){ hideSlotPreview(); return; }

      // ベースのサムネを生成後、更新日バッジを重ね描き
      generateThumbnailWithUpdatedAt(json, updatedAt, PREVIEW_W, PREVIEW_H).then((dataURL) => {
        slotThumbCache.set(cacheKey, dataURL);
        // すでに枠は出ているので src を付け替えるだけ
        slotPreviewImg.src = dataURL;
      }).catch(() => {
        hideSlotPreview();
      });
    }

    /**
     * 既存のサムネ生成結果へ「最終更新」バッジを重ねて返す。
     * @param {string} jsonText - Fabric JSON 文字列
     * @param {string|null} updatedAtISO - ISO 形式の更新日時
     * @param {number} [w=PREVIEW_W]
     * @param {number} [h=PREVIEW_H]
     * @returns {Promise<string>} dataURL
     */
    async function generateThumbnailWithUpdatedAt(jsonText, updatedAtISO, w=PREVIEW_W, h=PREVIEW_H){
      const baseURL = await generateThumbnailFromJSON(jsonText, w, h);
      // 合成用キャンバス
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d');
      await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { ctx.drawImage(img, 0, 0, w, h); resolve(); };
        img.onerror = reject;
        img.src = baseURL;
      });
      drawUpdatedAtBadge(c, updatedAtISO);
      return c.toDataURL('image/png');
    }

    /**
     * スロットボタン上にポップアップ表示するサムネイルを生成する。
     * v6 の Promise 返却に対応。旧版（callback）でも自動フォールバック。
     * @param {string|object} jsonText - Fabric JSON（文字列 or オブジェクト）
     * @param {number} [targetW=PREVIEW_W]
     * @param {number} [targetH=PREVIEW_H]
     * @returns {Promise<string>} dataURL
     */
    async function generateThumbnailFromJSON(jsonText, targetW = PREVIEW_W, targetH = PREVIEW_H) {
      return new Promise(async (resolve, reject) => {
        try {
          // ---- オフスクリーン StaticCanvas 準備（null は渡さない）----
          const offscreen = document.createElement('canvas');
          offscreen.width = targetW;
          offscreen.height = targetH;

          const sc = new fabric.StaticCanvas(offscreen, {
            width: targetW, height: targetH, backgroundColor: '#ffffff',
            enableRetinaScaling: false, renderOnAddRemove: false
          });

          const parsed = (typeof jsonText === 'string') ? JSON.parse(jsonText) : jsonText;
          const objsRaw = Array.isArray(parsed?.objects) ? parsed.objects : [];

          // 背景
          const bg = parsed.backgroundColor || parsed.background || '#ffffff';
          // sc.setBackgroundColor(bg, sc.renderAll.bind(sc));

          if (!objsRaw.length) {
            sc.renderAll();
            return resolve(offscreen.toDataURL('image/png'));
          }

          // 画像対策 reviver
          const reviver = (orig, obj) => {
            if (obj && obj.type === 'image' && !obj.crossOrigin) obj.crossOrigin = 'anonymous';
          };

          // v6: Promise / 旧版: callback 両対応
          let enlivened;
          const maybePromise = fabric.util.enlivenObjects(objsRaw, { reviver });
          if (maybePromise && typeof maybePromise.then === 'function') {
            enlivened = await maybePromise;
          } else {
            return fabric.util.enlivenObjects(
              objsRaw,
              (arr) => {
                try {
                  arr.forEach(o => sc.add(o));
                  sc.renderAll();
                  const url = _fitAndSnapshot(sc, targetW, targetH);
                  resolve(url);
                } catch (e) { reject(e); }
              },
              null,
              reviver
            );
          }

          enlivened.forEach(o => sc.add(o));
          sc.renderAll();

          const url = _fitAndSnapshot(sc, targetW, targetH);
          resolve(url);

        } catch (e) {
          reject(e);
        }
      });

      /**
       * 内部ヘルパー: 外接矩形にフィットさせて PNG を返す。
       * @param {fabric.StaticCanvas} sc
       * @param {number} targetW
       * @param {number} targetH
       * @returns {string} dataURL
       */
      function _fitAndSnapshot(sc, targetW, targetH) {
        const objs = sc.getObjects();
        if (!objs.length) {
          sc.renderAll();
          return sc.getElement().toDataURL('image/png');
        }
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const o of objs) {
          const br = o.getBoundingRect(true, true);
          minX = Math.min(minX, br.left);
          minY = Math.min(minY, br.top);
          maxX = Math.max(maxX, br.left + br.width);
          maxY = Math.max(maxY, br.top  + br.height);
        }
        const pad = FIT_PAD;
        const contentW = Math.max(1, (maxX - minX));
        const contentH = Math.max(1, (maxY - minY));
        const sx = (targetW - pad * 2) / contentW;
        const sy = (targetH - pad * 2) / contentH;
        const s  = Math.min(sx, sy);
        const tx = (-minX) * s + pad;
        const ty = (-minY) * s + pad;

        sc.setViewportTransform([ s, 0, 0, s, tx, ty ]);
        sc.renderAll();

        // StaticCanvas に渡した実体 canvas から取得
        return sc.getElement().toDataURL('image/png');
      }
    }

    // =========================
    // 更新日描画ユーティリティ
    // =========================
    /**
     * プレビュー画像の右下に「最終更新: yyyy/MM/dd hh:mm」バッジを描画。
     * @param {HTMLCanvasElement} canvasEl
     * @param {string|null} updatedAtISO
     */
    function drawUpdatedAtBadge(canvasEl, updatedAtISO){
      const ctx = canvasEl.getContext('2d');
      const text = '最終更新: ' + formatDateLabel(updatedAtISO);
      ctx.font = BADGE_FONT;
      const padX = BADGE_PAD_X;
      const padY = BADGE_PAD_Y;
      // 影響が少ないように事前にメジャー
      const metrics = ctx.measureText(text);
      const w = metrics.width + padX * 2;
      const h = 18 + padY * 2;
      const x = canvasEl.width  - w - BADGE_MARGIN;
      const y = canvasEl.height - h - BADGE_MARGIN;

      // 背景（角丸・白半透明）
      ctx.fillStyle = BADGE_BG;
      roundRect(ctx, x, y, w, h, BADGE_RADIUS);
      ctx.fill();
      // 枠線
      ctx.strokeStyle = BADGE_BORDER;
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, w, h, BADGE_RADIUS);
      ctx.stroke();
      // 文字
      ctx.fillStyle = BADGE_TEXT;
      ctx.fillText(text, x + padX, y + padY + 13);
    }
    /**
     * 角丸矩形パスを生成する。
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @param {number} r
     */
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    /**
     * ISO 文字列を「yyyy/MM/dd hh:mm」に整形する。
     * @param {string|null} iso
     * @returns {string}
     */
    function formatDateLabel(iso){
      if (!iso) return '(不明)';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return '(不明)';
      const y  = d.getFullYear();
      const m  = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${y}/${m}/${dd} ${hh}:${mm}`;
    }

    // =========================
    // 既存描画（要点）
    // =========================
    const groupOptions = { hasControls:true, hoverCursor:'move', originX:'left', originY:'top', opacity:1, objectCaching:false };

    function centerGroupLabel(group){
      if (!group || !group._label) return;
      const br = group.getBoundingRect(true, true);
      const centerCanvas = new fabric.Point(br.left + br.width/2, br.top + br.height/2);
      const m  = group.calcTransformMatrix();
      const im = fabric.util.invertTransform(m);
      const centerLocal = fabric.util.transformPoint(centerCanvas, im);
      group._label.set({ originX:'center', originY:'center', left:centerLocal.x, top:centerLocal.y, textAlign:'center' });
      group.setCoords();
    }
    function createLabeledGroup(baseObjects){
      const dropPoint = getDropPoint();
      const labelText = new fabric.Text('', { fontSize:16, fill:'#0f172a', originX:'center', originY:'center', top:0, left:0, textAlign:'center', objectCaching:false });
      baseObjects.forEach(o => o.set({ objectCaching:false, globalCompositeOperation:'source-over' }));
      const group = new fabric.Group([...baseObjects, labelText], { ...groupOptions, left: dropPoint.x, top: dropPoint.y, globalCompositeOperation:'source-over' });
      group._label = labelText;
      canvas.add(group);
      centerGroupLabel(group);
      canvas.setActiveObject(group);
      if (canvas.bringToFront) canvas.bringToFront(group);
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
      return group;
    }
    function addCircle(){
      const circle = new fabric.Circle({ left:0, top:0, radius:60, fill:'#22c55e', stroke:'#052e16', strokeWidth:3, strokeUniform:true });
      createLabeledGroup([circle]);
    }
    function addRect(){
      const rect = new fabric.Rect({ left:0, top:0, width:150, height:100, rx:8, ry:8, fill:'#60a5fa', stroke:'#0a2472', strokeWidth:3, strokeUniform:true });
      createLabeledGroup([rect]);
    }
    function addTextBox(){
      const drop = getDropPoint();
      const nextText = window.prompt('テキストを入力してください：', '');
      if (nextText === null) return;
      const tb = new fabric.Textbox(nextText, { left: drop.x, top: drop.y, fontSize:18, fill:'#0f172a', textAlign:'left', objectCaching:false });
      canvas.add(tb);
      canvas.setActiveObject(tb);
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }

    // 線
    let pendingLineStart = null;
    let previewLine = null;
    let previewLineArrowHead = null;

    function startLineDrawing(){
      const start = getDropPoint();
      pendingLineStart = { x: start.x, y: start.y };
      if (previewLine) { canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead) { canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }

      previewLine = new fabric.Line([start.x, start.y, start.x, start.y],{
        stroke: line_param.stroke, strokeWidth: line_param.strokeWidth, strokeLineCap: line_param.strokeLineCap,
        opacity:.6, selectable:false, evented:false, strokeDashArray:[6,6]
      });
      previewLineArrowHead = new fabric.Triangle({
        left:start.x, top:start.y, width:arrow_param.width, height:arrow_param.height, angle:0,
        fill:arrow_param.fill, stroke:arrow_param.stroke, strokeWidth:arrow_param.strokeWidth,
        originX:arrow_param.originX, originY:arrow_param.originY, selectable:false, evented:false
      });

      canvas.add(previewLine, previewLineArrowHead);
      canvas.bringToFront && canvas.bringToFront(previewLine);
      canvas.renderAll();
    }
    function calcurateArrowDegree(x1, y1, x2, y2) { return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; }
    function updateLinePreviewIfNeeded(){
      if (!pendingLineStart || !previewLine) return;
      const pos = getDropPoint();
      previewLine.set({ x2: pos.x, y2: pos.y });
      if (previewLineArrowHead){
        previewLineArrowHead.set({ left:pos.x, top:pos.y });
        previewLineArrowHead.set({ angle: calcurateArrowDegree(previewLine.x1, previewLine.y1, pos.x, pos.y) + 90 });
      }
      previewLine.setCoords();
      previewLineArrowHead && previewLineArrowHead.setCoords();
      canvas.renderAll();
    }
    function finalizeLineDrawingIfNeeded(domEvent){
      if (!pendingLineStart) return false;

      const hasPreview = !!previewLine;
      const x1 = hasPreview ? previewLine.x1 : pendingLineStart.x;
      const y1 = hasPreview ? previewLine.y1 : pendingLineStart.y;
      const x2 = hasPreview ? previewLine.x2 : canvas.getPointer(domEvent).x;
      const y2 = hasPreview ? previewLine.y2 : canvas.getPointer(domEvent).y;

      const minX = Math.min(x1, x2);
      const minY = Math.min(y1, y2);
      const p1 = { x: x1 - minX, y: y1 - minY };
      const p2 = { x: x2 - minX, y: y2 - minY };

      const shaftLine = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
        stroke: line_param.stroke, strokeWidth: line_param.strokeWidth, strokeLineCap: line_param.strokeLineCap,
      });
      const angleDeg = calcurateArrowDegree(x1, y1, x2, y2);
      const arrowHead = new fabric.Triangle({
        left:p2.x, top:p2.y, width:arrow_param.width, height:arrow_param.height, angle:angleDeg + 90,
        fill:arrow_param.fill, stroke:arrow_param.stroke, strokeWidth:arrow_param.strokeWidth,
        originX:arrow_param.originX, originY:arrow_param.originY,
      });

      const arrowGroup = new fabric.Group([shaftLine, arrowHead], { ...groupOptions, left:minX, top:minY });
      canvas.add(arrowGroup);
      canvas.setActiveObject(arrowGroup);

      if (previewLine){ canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead){ canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }
      pendingLineStart = null;
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      scheduleAutosave();
      pushHistory();
      return true;
    }
    function cancelLinePreview(render){
      if (previewLine){ canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead){ canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }
      pendingLineStart = null;
      if (render) canvas.renderAll();
    }

    // =========================
    // 操作ユーティリティ
    // =========================
    /**
     * スペースで色変更：
     * - 単体 Line は stroke を変更
     * - 単体の図形/テキスト/画像は fill（stroke を持つ場合は stroke も）を変更
     * - 矢印（Line + Triangle のグループ）は line.stroke と tri.fill/tri.stroke を同期して変更
     * @param {fabric.Object} obj
     */
    function cycleFillColor(obj){
      if (!obj) return;

      // パレット中の「次の色」を返す（見つからない場合は 0 番を返す）
      const nextColor = (cur) => {
        const s   = (cur || '').toString();
        const idx = color_palette.indexOf(s);
        const i   = idx >= 0 ? (idx + 1) % color_palette.length : 0;
        return color_palette[i];
      };

      // ---- グループ（矢印など） ----
      if (obj.type === 'group' && Array.isArray(obj._objects)){
        const line  = obj._objects.find(o => o.type === 'line');
        const tri   = obj._objects.find(o => o.type === 'triangle');
        const shape = obj._objects.find(o => ['rect','circle','path','textbox','text'].includes(o.type));

        // 矢印（line+triangle）: 同一色で統一
        if (line || tri){
          const base = (tri && (tri.fill || tri.stroke))
                    || (line && line.stroke)
                    || (shape && (shape.fill || shape.stroke))
                    || color_palette[0];
          const next = nextColor(base);
          if (line) line.set({ stroke: next });
          if (tri)  tri.set({ fill: next, stroke: next });
          // 他に図形が入っている場合も合わせる（あれば）
          if (shape){
            shape.set({ fill: next });
            if ('stroke' in shape) shape.set({ stroke: next });
          }
          obj.setCoords && obj.setCoords();
          canvas.renderAll();
          return;
        }

        // 通常のグループ：代表シェイプの色を回す
        if (shape){
          const base = shape.fill || shape.stroke || color_palette[0];
          const next = nextColor(base);
          shape.set({ fill: next });
          if ('stroke' in shape) shape.set({ stroke: next });
          obj.setCoords && obj.setCoords();
          canvas.renderAll();
          return;
        }
        // group だが該当なし → 以降の通常処理へフォールバック
      }

      // ---- 単体オブジェクト ----
      if (obj.type === 'line'){
        const base = obj.stroke || color_palette[0];
        const next = nextColor(base);
        obj.set({ stroke: next });
      }else if (obj.type === 'triangle'){
        // 単体三角形（念のため）
        const base = obj.fill || obj.stroke || color_palette[0];
        const next = nextColor(base);
        obj.set({ fill: next, stroke: next });
      }else{
        // 図形/テキスト/画像など
        const base = obj.fill || obj.stroke || color_palette[0];
        const next = nextColor(base);
        obj.set({ fill: next });
        if ('stroke' in obj) obj.set({ stroke: next });
      }
      obj.setCoords && obj.setCoords();
      canvas.renderAll();
    }

    function editLabelByDblClick(targetObject){
      if (!targetObject) return;
      const group = (targetObject.type === 'group') ? targetObject : targetObject.group;
      const isTextOnly = (targetObject.type === 'textbox' || targetObject.type === 'text');
      let labelText = null;

      if (group){
        labelText = group._label || (group._objects ? group._objects.find(o=>o.type==='text') : null);
        if (!labelText) return;
      }else if (isTextOnly){
        labelText = targetObject;
      }else return;

      const currentText = labelText.text || '';
      const nextText = window.prompt('図形のテキストを入力してください：', currentText);
      if (nextText === null) return;

      labelText.set({ text: nextText, textAlign:'center', originX:'center', originY:'center' });
      if (group){ centerGroupLabel(group); }
      (group || labelText).setCoords();
      canvas.renderAll();
    }
    function nudgeObject(obj, dx, dy){
      obj.set({ left: (obj.left||0)+dx, top: (obj.top||0)+dy });
      obj.setCoords();
      canvas.renderAll();
    }
    function duplicateObject(obj){
      if (!obj) return;
      obj.clone().then((clone) => {
        clone.set({ left: (obj.left || 0) + 32, top:  (obj.top  || 0) + 32 });
        canvas.add(clone);
        canvas.setActiveObject(clone);
        const render = canvas.requestRenderAll || canvas.renderAll;
        render.call(canvas);
        pushHistory();
      }).catch((err) => console.error('clone failed:', err));
    }
    function rotateObject(obj, deg){
      obj.rotate((obj.angle || 0) + deg);
      obj.setCoords();
      canvas.renderAll();
    }

    /**
     * キャンバスの拡大・縮小をリセットする。
     */ 
    function zoomResetCanvas() {
      //倍率を1に設定する
      canvas.setZoom(1);
      //左上を原点に移動する
      canvas.absolutePan( new fabric.Point(0,0) );
    }

    // =========================
    // 削除（複数選択対応）
    // =========================
    function removeSelected(){
      const selected = canvas.getActiveObjects();
      if (!selected || !selected.length) return;
      selected.forEach(o => canvas.remove(o));
      canvas.discardActiveObject();
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
      scheduleAutosave();
      pushHistory();
    }

    // =========================
    // イベント
    // =========================
    canvas.on('mouse:move', (evt) => {
      const p = canvas.getPointer(evt.e);
      lastPointer = { x: p.x, y: p.y };
      updateLinePreviewIfNeeded();
    });
    canvas.upperCanvasEl.addEventListener('dblclick', (domEvt) => {
      const target = canvas.findTarget(domEvt, true);
      if (!target) return;
      editLabelByDblClick(target);
    });
    canvas.on('mouse:down', (evt) => {
      if (finalizeLineDrawingIfNeeded(evt.e)) return;
      if (!evt.target){ canvas.discardActiveObject(); canvas.renderAll(); }
    });
    canvas.on('mouse:wheel', (opt) => {
      // Ctrlキー押下時のみ
      if (!opt.e.ctrlKey) { return; }

      const delta = opt.e.deltaY;
      let z = canvas.getZoom();
      // ---- ホイール倍率更新 ----
      z *= Math.pow(ZOOM_WHEEL_FACTOR, delta);
      z = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, z));
      canvas.zoomToPoint({x:opt.e.offsetX,y:opt.e.offsetY}, z);
      opt.e.preventDefault(); opt.e.stopPropagation();
      // ズーム時は拡大率/右上ワールド座標のみ保存（updatedAtは変更しない）
      try{
        saveViewportMeta(currentSlot, { touchUpdatedAt: false });
      }catch(_){}
    });

    function handleKeydown(ev){
      const tag = (document.activeElement && document.activeElement.tagName) || '';
      if (tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT') return;
      if (ev.isComposing || ev.repeat) return;

      const keyLower = (ev.key || '').toLowerCase();
      const code = ev.code || '';
      const active = canvas.getActiveObject();
      const isCtrl = ev.ctrlKey || ev.metaKey;

      // Esc: 拡大縮小・ポイントリセット
      if (keyLower === 'escape'){ ev.preventDefault(); zoomResetCanvas(); saveViewportMeta(currentSlot, { touchUpdatedAt: false }); return; }

      // Undo/Redo
      if (isCtrl && keyLower === 'z' && ev.shiftKey){ ev.preventDefault(); redo(); return; }
      if (isCtrl && keyLower === 'z'){ ev.preventDefault(); undo(); return; }

      // Select All
      if (isCtrl && (keyLower === 'a' || code === 'KeyA')){
        ev.preventDefault();
        const objs = canvas.getObjects();
        if (objs.length){
          const sel = new fabric.ActiveSelection(objs, { canvas });
          canvas.setActiveObject(sel);
          const render = canvas.requestRenderAll || canvas.renderAll;
          render.call(canvas);
        }
        return;
      }

      // 追加
      if (keyLower==='c' || code==='KeyC'){ ev.preventDefault(); addCircle(); scheduleAutosave(); pushHistory(); return; }
      if (keyLower==='s' || code==='KeyS'){ ev.preventDefault(); addRect();   scheduleAutosave(); pushHistory(); return; }
      if (keyLower==='t' || code==='KeyT'){ ev.preventDefault(); addTextBox(); scheduleAutosave(); pushHistory(); return; }

      // 線
      if (keyLower==='a' || code==='KeyA'){ ev.preventDefault(); startLineDrawing(); return; }
      if (keyLower==='escape' || code==='Escape'){ ev.preventDefault(); cancelLinePreview(true); return; }

      // 移動
      if (active){
        const step = ev.shiftKey ? 10 : 1;
        if (keyLower==='arrowup'){ ev.preventDefault(); nudgeObject(active,0,-step); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowdown'){ ev.preventDefault(); nudgeObject(active,0, step); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowleft'){ ev.preventDefault(); nudgeObject(active,-step,0); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowright'){ ev.preventDefault(); nudgeObject(active, step,0); scheduleAutosave(); pushHistoryDebounced(); return; }
      }

      // 複製（Ctrl+D）
      if (isCtrl && keyLower==='d'){ ev.preventDefault(); duplicateObject(active); scheduleAutosave(); return; }

      // Delete/Backspace / d で削除
      if (keyLower==='delete' || keyLower==='backspace'){ ev.preventDefault(); removeSelected(); return; }
      if (keyLower==='d'){ ev.preventDefault(); removeSelected(); return; }

      // Enter: テキスト編集
      if (keyLower==='enter' || code==='Enter'){ ev.preventDefault(); if (active) editLabelByDblClick(active); scheduleAutosave(); pushHistoryDebounced(); return; }

      // Space: 色
      if (keyLower===' ' || keyLower==='spacebar' || code==='Space'){ ev.preventDefault(); if (active) cycleFillColor(active); scheduleAutosave(); pushHistoryDebounced(); return; }

      // 回転/スケール
      if (keyLower==='r'){ ev.preventDefault(); if (active) { rotateObject(active, ev.shiftKey ? -15 : 15); scheduleAutosave(); pushHistoryDebounced(); } return; }
      if (keyLower==='+'){ ev.preventDefault(); if (active){ active.set({ scaleX:(active.scaleX||1)*(ev.shiftKey?1.25:1.1), scaleY:(active.scaleY||1)*(ev.shiftKey?1.25:1.1) }); active.setCoords(); canvas.renderAll(); scheduleAutosave(); pushHistoryDebounced(); } return; }
      if (keyLower==='-'){ ev.preventDefault(); if (active){ active.set({ scaleX:(active.scaleX||1)*(ev.shiftKey?0.8:0.9),  scaleY:(active.scaleY||1)*(ev.shiftKey?0.8:0.9)  }); active.setCoords(); canvas.renderAll(); scheduleAutosave(); pushHistoryDebounced(); } return; }
    }
    window.addEventListener('keydown', handleKeydown, true);

    // クリックでフォーカス
    document.addEventListener('pointerdown', () => { canvasEl.focus({preventScroll:true}); });

    // Shift + ホイールでスロット切替
    canvas.upperCanvasEl.addEventListener('wheel', (e) => {
      if (!e.shiftKey) return;
      e.preventDefault();
      const dir = e.deltaY > 0 ? 1 : -1;
      selectSlot(currentSlot + dir);
      hideSlotPreview();
    }, { passive: false });

    // PNG出力
    pngBtn.addEventListener('click', () => {
      const dataURL = canvas.toDataURL({ format:'png', multiplier:2, enableRetinaScaling:false });
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = `canvas-slot${currentSlot+1}.png`;
      document.body.appendChild(a); a.click(); a.remove();
    });

    // 画像挿入
    imageBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'image/*';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = String(reader.result || ''); if (!dataURL) return;
          fabric.Image.fromURL(dataURL, (img) => {
            const drop = getDropPoint();
            const maxW = canvas.getWidth()*0.6, maxH = canvas.getHeight()*0.6;
            const scale = Math.min(1, maxW/img.width, maxH/img.height);
            img.set({ originX:'center', originY:'center', left:drop.x, top:drop.y, scaleX:scale, scaleY:scale, objectCaching:false });
            canvas.add(img);
            canvas.setActiveObject(img);
            const render = canvas.requestRenderAll || canvas.renderAll;
            render.call(canvas);
            scheduleAutosave(); pushHistory();
          }, { crossOrigin: null });
        };
        reader.readAsDataURL(file);
      };
      input.click();
    });

    // クリア
    clearBtn.addEventListener('click', () => {
      const ok = window.confirm(`スロット ${currentSlot + 1} の全オブジェクトを削除します。\nこの操作は元に戻せません。よろしいですか？`);
      if (!ok) return;
      canvas.clear();
      setCanvasBg('#ffffff');
      // タイトルもクリア（要件：クリアボタンでタイトルも空に）
      try{
        clearSlotTitle(currentSlot);
      }catch(_){}
      // 視点リセット＆保存
      // クリア直後の視点（ズーム1・原点）を保存しておく（updatedAt は編集として更新）
      canvas.setViewportTransform([1,0,0,1,0,0]);
      saveToSlot(currentSlot);
      resetHistoryBaseline();
    });

    // JSON入出力
    importBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'application/json';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try{
            canvas.clear(); setCanvasBg('#ffffff');
            applyingHistory = true;
            importCanvasJSON(String(reader.result), () => {
              applyingHistory = false;
              // インポート直後は今の視点（ズーム1/原点）。保存時に meta も併せて保存。
              saveToSlot(currentSlot);
              resetHistoryBaseline();
              refreshSlotButtonsUI();
            });
          }catch(e){ console.error('import failed:', e); applyingHistory=false; }
        };
        reader.readAsText(file);
      };
      input.click();
    });
    exportBtn.addEventListener('click', () => {
      // エクスポートは fabric JSON（外部交換しやすい）
      const json = exportCanvasJSON();
      const blob = new Blob([json], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `canvas-export-slot${currentSlot+1}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    });

    // =========================
    // 初期化
    // =========================
    buildSlotButtons();
    resizeCanvasToViewport();
    currentSlot = 0;
    refreshSlotButtonsUI();
    loadFromSlot(currentSlot);
    canvasEl.focus({preventScroll:true});
    resetHistoryBaseline();

  })();
  </script>
</body>
</html>
