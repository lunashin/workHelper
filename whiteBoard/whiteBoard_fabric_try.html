<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Fabric.js 図形作成ツール（保守性向上版）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --fg:#0f172a;
      --line:#3a3c44;
      --slotBg:#f5f7fb;
      --slotSel:#0ea5e9;
      --slotTxt:#0b1323;
      --slotEmptyBg:#f1f5f9;
      --slotEmptyTxt:#94a3b8;
      /* データあり（淡いオレンジ） */
      --slotHasBg:#fff1e6;
      --slotHasBorder:#f59e0b;
      --slotHasTxt:#9a3412;
    }
    html,body{height:100%;margin:0;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"ヒラギノ角ゴ ProN",Meiryo,sans-serif;}
    header{padding:10px 14px;border-bottom:1px solid var(--line);display:flex;gap:18px;align-items:center;flex-wrap:wrap;}
    .kbd{padding:.2em .45em;border:1px solid var(--line);border-bottom-width:2px;border-radius:6px;font-weight:600;background:#f2f3f5;}
    #wrap{height:calc(100% - 104px);}
    #stage{display:block;outline:none;background:#fff;}
    .upper-canvas{background: transparent !important;}

    /* ツールバー */
    #toolbar{display:flex;align-items:center;gap:10px;padding:8px 14px;border-bottom:1px solid var(--line);background:#fafbff;flex-wrap:wrap;}
    .slot-btn{
      min-width:38px;padding:6px 10px;border:1px solid #cfd6e3;border-radius:8px;
      background:var(--slotBg);color:var(--slotTxt);font-weight:600;cursor:pointer;user-select:none;position:relative;
      transition:background .15s ease,border-color .15s ease,color .15s ease;
    }
    .slot-btn.active{
      border-color:var(--slotSel);box-shadow:0 0 0 2px rgba(14,165,233,.2) inset;color:var(--slotSel);background:#e8f6fd;
    }
    .slot-btn.empty{
      background:var(--slotEmptyBg);color:var(--slotEmptyTxt);border-style:dashed;
    }
    .slot-btn.hasdata{
      background:var(--slotHasBg);border-color:var(--slotHasBorder);color:var(--slotHasTxt);
    }
    .toolbar-button{padding:6px 12px;border:1px solid #cfd6e3;border-radius:8px;background:#ffffff;font-weight:600;cursor:pointer;}
    .toolbar-button:hover{background:#f6f8fc;}
    .spacer{flex:1 1 auto;}
    /* ペンツールの見た目 */
    .pen-btn{min-width:38px}
    .pen-btn.active{background:#e8f6fd;border-color:#0ea5e9;box-shadow:0 0 0 2px rgba(14,165,233,.2) inset;color:#0ea5e9}
    #penColor{width:36px;height:32px;padding:0;border-radius:8px;border:1px solid #cfd6e3;cursor:pointer}
    #penColor::-webkit-color-swatch{border:none;border-radius:6px}

    /* スロットサムネプレビュー */
    #slotPreview{
      position:fixed;left:0;top:0;transform: translate(12px, 12px);
      display:none;z-index:9999;background:#fff;border:1px solid rgba(0,0,0,.12);
      box-shadow:0 10px 24px rgba(2,6,23,.15);border-radius:10px;padding:6px;pointer-events:none;
    }
    #slotPreview .title{
      font-size:13px;font-weight:700;color:#0b1323;text-align:center;margin:4px 6px 6px;
    }
    #slotPreview img{display:block;max-width:420px;max-height:270px;border-radius:6px;}
    #slotPreview .meta{
      font-size:12px;color:#475569;margin:6px 6px 2px;text-align:center;
    }

  </style>
</head>
<body>
  <header id="header">
    <div>
      <span class="kbd">c</span> 円 /
      <span class="kbd">s</span> 四角 /
      <span class="kbd">r</span> 菱形 /
      <span class="kbd">t</span> テキスト /
      <span class="kbd">a</span> 線
    </div>
    <div>
      <span class="kbd">Ctrl|⌘ + Z</span> Undo /
      <span class="kbd">Ctrl|⌘ + Shift + Z</span> Redo /
      <span class="kbd">Ctrl|⌘ + A</span> すべて選択 /
      <span class="kbd">d</span> 選択削除
    </div>
  </header>

  <div id="toolbar" aria-label="保存スロットとエクスポート">
    <div id="slotButtons"></div>
    <div class="spacer"></div>
    <button id="imageBtn" class="toolbar-button" type="button">画像挿入</button>
    <button id="pngBtn" class="toolbar-button" type="button">PNG出力</button>
    <button id="importBtn" class="toolbar-button" type="button">JSONインポート</button>
    <button id="exportBtn" class="toolbar-button" type="button">JSONエクスポート</button>
    <!-- ペン：太さ3種 & 色 -->
    <div style="width:1px;height:28px;background:#e5e7eb;margin:0 6px"></div>
    <button id="penThinBtn"  class="toolbar-button pen-btn" type="button" title="細ペン">✎ 細</button>
    <button id="penMidBtn"   class="toolbar-button pen-btn" type="button" title="中ペン">✎ 中</button>
    <button id="penThickBtn" class="toolbar-button pen-btn" type="button" title="太ペン">✎ 太</button>
    <input  id="penColor" type="color" value="#111827" title="ペン色" />
    <button id="titleBtn" class="toolbar-button" type="button">タイトル変更</button>
    <button id="clearBtn" class="toolbar-button" type="button">クリア</button>
  </div>

  <div id="wrap">
    <canvas id="stage" tabindex="0" aria-label="図形キャンバス"></canvas>
  </div>

  <div id="slotPreview" aria-hidden="true">
    <div class="title"></div>
    <img alt="slot preview" />
    <div class="meta"></div>
  </div>

  <!-- Fabric.js v6.7.1 -->
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/671/index.min.js"></script> -->
  <script src="./fabric.js/671/index.min.js"></script>

  <script>
  (function(){
    // =========================
    // 開発支援用ログ
    // =========================
    const DEBUG = false;
    const D = (...a) => DEBUG && console.log('[dbg]', ...a);

    // =========================
    // ネットワークガード（外部通信の検知とブロック）
    // =========================
    /**
     * URL を文字列に正規化
     * - Request / URL / string に対応
     * @param {any} input
     * @returns {string}
     */
    function toURLString(input){
      try{
        if (!input) return '';
        if (typeof input === 'string') return input;
        if (input instanceof Request) return input.url || '';
        if (input instanceof URL) return String(input.href || '');
        // fetch の第一引数に {url:"..."} のようなパターン対策
        if (typeof input === 'object' && 'url' in input && typeof input.url === 'string') return input.url;
      }catch(_){}
      return '';
    }
    /**
     * 与えられた URL が「外部サーバ」かどうかを判定
     * - data:, blob:, file: は許可
     * - http/https は「同一オリジン(origin)のみ許可」、それ以外はブロック
     * - 相対パスは同一オリジンとして解決
     * @param {string} urlStr
     * @returns {boolean} true: 外部（ブロック対象）/ false: 許可
     */
    function isExternalURL(urlStr){
      if (!urlStr) return false; // 何も無ければスルー（この後で失敗）
      try{
        // data/blob/file は常に許可
        if (urlStr.startsWith('data:')) return false;
        if (urlStr.startsWith('blob:')) return false;
        if (urlStr.startsWith('file:')) return false;

        const base = (location && location.href) ? location.href : 'http://localhost/';
        const u = new URL(urlStr, base);
        // http/https 以外（例: chrome-extension:）は外部扱いとしてブロック
        if (u.protocol !== 'http:' && u.protocol !== 'https:') return true;
        // 同一オリジンなら許可、異なるオリジンはブロック
        return u.origin !== location.origin;
      }catch(_){
        // パースできないものは念のためブロック
        return true;
      }
    }
    /**
     * 検知時にユーザへ通知し、ブロックを明示
     * @param {string} apiName
     * @param {string} urlStr
     */
    function notifyBlocked(apiName, urlStr){
      try{
        // 連続表示を避けるなら簡易デバウンス（必要なら有効化）
        alert(`外部サーバへの通信を検出しブロックしました。\nAPI: ${apiName}\nURL: ${urlStr}`);
        console.warn('[blocked external request]', apiName, urlStr);
      }catch(_){}
    }
    /**
     * ネットワークフックの設置
     */
    (function installNetworkGuards(){
      // ---- fetch ----
      if (typeof window.fetch === 'function'){
        const _fetch = window.fetch.bind(window);
        window.fetch = function(input, init){
          const urlStr = toURLString(input);
          if (isExternalURL(urlStr)){
            notifyBlocked('fetch', urlStr);
            return Promise.reject(new Error('Blocked external fetch: ' + urlStr));
          }
          return _fetch(input, init);
        };
      }
      // ---- XMLHttpRequest ----
      if (typeof window.XMLHttpRequest === 'function'){
        const _open = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url){
          const urlStr = toURLString(url);
          // open の時点で判定（send 前）
          this.__wb_checked_url__ = urlStr;
          if (isExternalURL(urlStr)){
            this.__wb_blocked__ = true;
            notifyBlocked('XMLHttpRequest', urlStr);
          }else{
            this.__wb_blocked__ = false;
          }
          return _open.apply(this, arguments);
        };
        const _send = XMLHttpRequest.prototype.send;
        XMLHttpRequest.prototype.send = function(body){
          if (this.__wb_blocked__){
            // 送信せずにエラー状態へ
            try{ this.abort(); }catch(_){}
            throw new Error('Blocked external XMLHttpRequest: ' + (this.__wb_checked_url__ || ''));
          }
          return _send.apply(this, arguments);
        };
      }
      // ---- WebSocket ----
      if (typeof window.WebSocket === 'function'){
        const _WS = window.WebSocket;
        window.WebSocket = function(url, protocols){
          const urlStr = toURLString(url);
          // ws(s) のオリジン判定（location とホスト比較）。URL の host:port が一致しなければ外部扱い
          try{
            const base = (location && location.href) ? location.href : 'http://localhost/';
            const u = new URL(urlStr, base);
            const sameHost = (u.hostname === location.hostname) && ((u.port||'') === (location.port||''));
            if (!sameHost){
              notifyBlocked('WebSocket', urlStr);
              throw new Error('Blocked external WebSocket: ' + urlStr);
            }
          }catch(_){
            notifyBlocked('WebSocket', urlStr);
            throw new Error('Blocked external WebSocket: ' + urlStr);
          }
          return new _WS(url, protocols);
        };
        window.WebSocket.prototype = _WS.prototype;
      }
      // ---- EventSource ----
      if (typeof window.EventSource === 'function'){
        const _ES = window.EventSource;
        window.EventSource = function(url, config){
          const urlStr = toURLString(url);
          if (isExternalURL(urlStr)){
            notifyBlocked('EventSource', urlStr);
            throw new Error('Blocked external EventSource: ' + urlStr);
          }
          return new _ES(url, config);
        };
        window.EventSource.prototype = _ES.prototype;
      }
      // ---- sendBeacon ----
      if (navigator && typeof navigator.sendBeacon === 'function'){
        const _sb = navigator.sendBeacon.bind(navigator);
        navigator.sendBeacon = function(url, data){
          const urlStr = toURLString(url);
          if (isExternalURL(urlStr)){
            notifyBlocked('sendBeacon', urlStr);
            return false; // 送信しない
          }
          return _sb(url, data);
        };
      }
      // ---- Image.src（透過的に外部URL読み込みをブロック）----
      try{
        const desc = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
        if (desc && desc.set){
          const origSet = desc.set;
          Object.defineProperty(HTMLImageElement.prototype, 'src', {
            set(value){
              const urlStr = String(value || '');
              if (isExternalURL(urlStr)){
                notifyBlocked('Image.src', urlStr);
                // ブロック：空画像に差し替え（1x1透明PNG）
                const emptyPNG = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';
                return origSet.call(this, emptyPNG);
              }
              return origSet.call(this, value);
            }
          });
        }
      }catch(_){}
    })();


    // =========================
    // 共通定数（“魔法数”の排除）
    // =========================
    // プレビュー画像サイズ
    const PREVIEW_W = 420;
    const PREVIEW_H = 270;
    // サムネイルの外接矩形フィット用パディング
    const FIT_PAD = 12;
    // 更新日バッジの描画スタイル
    const BADGE_FONT = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    const BADGE_PAD_X = 8;
    const BADGE_PAD_Y = 6;
    const BADGE_RADIUS = 8;
    const BADGE_MARGIN = 8;
    const BADGE_BG = 'rgba(255,255,255,0.92)';
    const BADGE_BORDER = 'rgba(0,0,0,0.15)';
    const BADGE_TEXT = '#334155';
    // スロット数
    const SLOT_COUNT = 20;
    // LocalStorage キー
    const LS_KEY_PREFIX = 'wb_slot_v1_';
    const LS_KEY_META_PREFIX = 'wb_slot_v1_meta_';
    // スロットタイトル保存用
    const LS_KEY_TITLE_PREFIX = 'wb_slot_title_v1_';
    // クリップボード（スロットを跨いでも有効）
    const CLIPBOARD_KEY = 'wb_clipboard_v1';
    // オートセーブ
    const AUTOSAVE_DELAY = 300;
    // ズーム制御
    const ZOOM_MIN = 0.2;
    const ZOOM_MAX = 5;
    const ZOOM_WHEEL_FACTOR = 0.999;
    // Undo/Redo 履歴件数
    const HISTORY_LIMIT = 50;
    // ---- 矢印プレビューのスナップ設定（水平・垂直）----
    // 画面ピクセルでの判定幅（ズームに依らず体感一定）
    const ARROW_SNAP_TOL_PX = 10;

    // // ---- (0,0) マーカー描画用 ----
    // const ORIGIN_MARK_SIZE = 10;                // 十字の半分の長さ(px, 画面座標で固定)
    // const ORIGIN_MARK_LINEW = 1;                // 線幅
    // const ORIGIN_MARK_COLOR = 'rgba(2,6,23,.25)'; // やや淡い色（#020617 25%）
    // const ORIGIN_MARK_DOT = 3;                  // 中心の点の半径
    // ---- (0,0) マーカー（ワールド固定オブジェクト）----
    const ORIGIN_MARK_SIZE_WORLD = 20;          // 十字の半分の長さ（ワールド座標単位）
    const ORIGIN_MARK_LINEW_WORLD = 1;          // 線幅（ワールド座標単位）
    const ORIGIN_MARK_COLOR = 'rgba(2,6,23,.25)'; // 淡い色
    const ORIGIN_MARK_DOT_WORLD = 3;            // 中心点の半径（ワールド座標単位）
    const ORIGIN_MARK_HINT = false;             // trueで "(0,0)" の小ラベルも描画
    // 原点マーカー参照
    let originMarker = null;

    // =========================
    // DOM 参照
    // =========================
    const canvasEl = document.getElementById('stage');
    const headerEl = document.getElementById('header');
    const toolbarEl = document.getElementById('toolbar');
    const slotButtonsEl = document.getElementById('slotButtons');
    const exportBtn = document.getElementById('exportBtn');
    const imageBtn  = document.getElementById('imageBtn');
    const importBtn = document.getElementById('importBtn');
    const clearBtn  = document.getElementById('clearBtn');
    const titleBtn  = document.getElementById('titleBtn');
    const pngBtn    = document.getElementById('pngBtn');
    const slotPreviewEl = document.getElementById('slotPreview');
    const slotPreviewImg = slotPreviewEl.querySelector('img');
    const slotPreviewTitle = slotPreviewEl.querySelector('.title');
    const slotPreviewMeta  = slotPreviewEl.querySelector('.meta');
    // ペンUI
    const penThinBtn  = document.getElementById('penThinBtn');
    const penMidBtn   = document.getElementById('penMidBtn');
    const penThickBtn = document.getElementById('penThickBtn');
    const penColorInp = document.getElementById('penColor');

    // =========================
    // Fabric Canvas 初期化
    // =========================
    const canvas = new fabric.Canvas(canvasEl, {
      backgroundColor: '#ffffff',
      selection: true,
      preserveObjectStacking: true
    });

    // =========================
    // ペンモード
    // =========================
    let penMode = false;
    let penWidth = 2;       // 既定の太さ
    let penColor = '#111827';

    function applyPenBrush(){
      // Fabric v6: PencilBrush はデフォルトで利用可
      canvas.isDrawingMode = true;
      canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
      canvas.freeDrawingBrush.width = penWidth;
      canvas.freeDrawingBrush.color = penColor;
    }
    function setPenUIActive(targetBtn){
      [penThinBtn, penMidBtn, penThickBtn].forEach(b=>b.classList.toggle('active', b===targetBtn && penMode));
    }
    function enterPenMode(width, fromBtn){
      penWidth = width;
      penColor = penColorInp.value || penColor;
      penMode = true;
      // 選択系を無効化（図形の選択不可）
      canvas.discardActiveObject();
      canvas.selection = false;
      canvas.skipTargetFind = true;
      applyPenBrush();
      setPenUIActive(fromBtn || null);
    }
    function exitPenMode(){
      if (!penMode) return;
      penMode = false;
      canvas.isDrawingMode = false;
      // 選択系を元に戻す
      canvas.selection = true;
      canvas.skipTargetFind = false;
      setPenUIActive(null);
      (canvas.requestRenderAll || canvas.renderAll).call(canvas);
    }
    // ペンUIイベント
    penThinBtn.addEventListener('click',  ()=> enterPenMode(2,  penThinBtn));
    penMidBtn .addEventListener('click',  ()=> enterPenMode(5,  penMidBtn));
    penThickBtn.addEventListener('click', ()=> enterPenMode(10, penThickBtn));
    penColorInp.addEventListener('input', ()=>{
      penColor = penColorInp.value || penColor;
      if (penMode && canvas.freeDrawingBrush){
        canvas.freeDrawingBrush.color = penColor;
      }
    });
    // 手描き完了時にオートセーブ＆履歴
    canvas.on('path:created', ()=>{
      scheduleAutosave();
      pushHistoryDebounced();
    });

    /**
     * Fabric のグリップ/枠線の見た目を初期設定する。
     * 引数/戻り値なし（副作用：fabric.Object.prototype を変更）
     */
    // ---- 選択ハンドルのテーマ設定 ----
    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.cornerColor = '#0ea5e9';
    fabric.Object.prototype.cornerStyle = 'rect';
    fabric.Object.prototype.cornerSize = 10;
    fabric.Object.prototype.borderColor = '#0ea5e9';

    // カラーパレット
    const color_palette = ['#60a5fa','#22c55e','#f59e0b','#ef4444','#a78bfa', 'gray', '#ffffff', '#000000'];

    // 図形作成時の既定パラメータ
    const line_param = { stroke:'#111827', strokeWidth:3, strokeLineCap:'round' };
    const arrow_param = { width:32, height:32, fill:'#111827', stroke:'#111827', strokeWidth:2, originX:'center', originY:'center' };

    /**
     * ビューポートに合わせて Canvas のピクセルサイズを追従させる。
     * 引数なし / 戻り値なし（canvas に副作用）
     */
    function resizeCanvasToViewport(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const hh = Math.ceil(headerEl.getBoundingClientRect().height);
      const th = Math.ceil(toolbarEl.getBoundingClientRect().height);
      // ---- レイアウト計算 ----
      canvas.setWidth(vw);
      const usableHeight = Math.max(0, vh - hh - th);
      canvas.setHeight(usableHeight);
      canvas.calcOffset();
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }
    window.addEventListener('resize', resizeCanvasToViewport, { passive:true });

    let lastPointer = null;
    /**
     * 直近のマウス位置（なければキャンバス中央）を返す。
     * @returns {{x:number,y:number}} ドロップ配置の基準点
     */
    function getDropPoint(){
      if (lastPointer) return lastPointer;
      return { x: canvas.getWidth()/2, y: canvas.getHeight()/2 };
    }

    // =========================
    // スロット機能
    // =========================
    // ※ 視点メタデータ（ズーム/右上ワールド座標/updatedAt）は LS_KEY_META_PREFIX に保存
    let currentSlot = 0;
    let autosaveTimer = null;

    /**
     * 現在のキャンバス内容を Fabric JSON 文字列として返す。
     * @returns {string} JSON 文字列
     */
    function exportCanvasJSON(){
      const json = canvas.toJSON();
      return JSON.stringify(json, null, 2);
    }
    /**
     * Fabric JSON 文字列を読み込み、キャンバスへ反映する。
     * @param {string} jsonText - Fabric JSON 文字列
     * @param {Function} [cb] - 読み込み完了後に呼ばれるコールバック
     * @returns {void}
     */
    function importCanvasJSON(jsonText, cb){
      try{
        const parsed = JSON.parse(jsonText);
        // canvas.loadFromJSON(parsed, () => {
        // 旧データに含まれる blob:null 画像を除去してからロード
        sanitizeFabricJSON(parsed);
        canvas.loadFromJSON(parsed, () => {
          attachGroupLabelPointers();
          const render = canvas.requestRenderAll || canvas.renderAll;
          render.call(canvas);
          // 読み込み後に原点マーカーを復元＆背面へ
          ensureOriginMarker(); keepOriginMarkerBack();
          canvasEl.focus({preventScroll:true});
          cb && cb();
        });
      }catch(err){ console.error('loadFromJSON failed:', err); }
    }
    /**
     * グループ内のラベル(Text)への参照を付与し、中央へ配置し直す。
     * @returns {void}
     */
    function attachGroupLabelPointers(){
      for (const obj of canvas.getObjects()){
        if (obj.type === 'group' && obj._objects){
          const label = obj._objects.find(o => o.type === 'text');
          if (label) obj._label = label;
          if (obj._label) centerGroupLabel(obj);
        }
      }
    }
    /**
     * 現在のスロットへキャンバス JSON を保存し、視点メタも保存する。
     * （updatedAt は編集時のみ更新。ズーム時は更新しない）
     * @param {number} slot - 保存先スロット番号
     */
    function saveToSlot(slot){
      try{
        const key = LS_KEY_PREFIX + slot;
        localStorage.setItem(key, exportCanvasJSON());
        // ---- 視点メタも一緒に保存（最終更新日時は編集時のみ更新）----
        saveViewportMeta(slot);
        refreshSlotButtonsUI();
      }catch(err){ console.error('saveToSlot failed:', err); }
    }
    /**
     * スロットからキャンバス JSON を読み込み、視点メタを復元する。
     * @param {number} slot - 読み込み元スロット番号
     */
    function loadFromSlot(slot){
      const key = LS_KEY_PREFIX + slot;
      const json = localStorage.getItem(key);
      if (!json){
        canvas.clear();
        setCanvasBg('#ffffff');
        // クリア時も原点マーカーを再配置
        ensureOriginMarker(); keepOriginMarkerBack();
        return;
      }
      importCanvasJSON(json, () => {
        // ---- 視点メタを復元（あれば）----
        applyViewportFromMeta(slot);
        ensureOriginMarker(); keepOriginMarkerBack();
      });
    }
    /**
     * キャンバス背景色を設定して再描画。
     * @param {string} color - CSS 色
     */
    function setCanvasBg(color){
      canvas.backgroundColor = color;
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }

    // =========================
    // Fabric JSON サニタイズ（blob:null 画像対策）
    // =========================
    /**
     * Fabric JSON オブジェクト内から、復元不能な画像（src が blob:）を除去する。
     * - 既存の古い保存データに含まれる blob:null/... を取り除き、読み込み失敗を防ぐ
     * - グループ内も再帰的に処理。子が全滅したグループは除去。
     * @param {object} parsed - canvas.loadFromJSON に渡す前の JSON オブジェクト
     * @returns {object} 破壊的に編集後の同オブジェクトを返す
     */
    function sanitizeFabricJSON(parsed){
      try{
        const isBadImage = (o) => o && o.type === 'image'
          && typeof o.src === 'string'
          && o.src.startsWith('blob:'); // blob: は再ロード不可

        const cleanArray = (arr) => {
          const out = [];
          for (const o of (arr || [])){
            if (!o) continue;
            if (isBadImage(o)) continue; // 破棄
            // group 内の子オブジェクトもクリーン
            if (Array.isArray(o.objects)){ // v6系で group は objects 配列
              o.objects = cleanArray(o.objects);
              // 子が空ならこの group 自体も除去
              if (!o.objects.length) continue;
            }else if (Array.isArray(o._objects)){ // 念のため旧キーも対応
              o._objects = cleanArray(o._objects);
              if (!o._objects.length) continue;
            }
            out.push(o);
          }
          return out;
        };

        if (Array.isArray(parsed.objects)){
          parsed.objects = cleanArray(parsed.objects);
        }
      }catch(_){}
      return parsed;
    }

    /**
     * スロットタイトル取得
     * @param {number} slot
     * @returns {string|null} 空文字は有効なタイトル、未設定は null
     */
    function getSlotTitle(slot){
      const v = localStorage.getItem(LS_KEY_TITLE_PREFIX + slot);
      return (v === null) ? null : v;
    }
    /**
     * スロットタイトル設定（空文字可）
     * @param {number} slot
     * @param {string} title
     */
    function setSlotTitle(slot, title){
      if (title === null || title === undefined) return;
      localStorage.setItem(LS_KEY_TITLE_PREFIX + slot, String(title));
    }
    function clearSlotTitle(slot){ localStorage.removeItem(LS_KEY_TITLE_PREFIX + slot); }

    /**
     * 原点(0,0)マーカーをワールド座標に固定配置する。
     * - Fabricオブジェクトとして追加（ズーム/パンに追従）
     * - selectable:false, evented:false, excludeFromExport:true
     * - レイヤー最背面へ配置
     */
    function ensureOriginMarker(){
      if (originMarker && canvas.getObjects().includes(originMarker)) return;
      const L = ORIGIN_MARK_SIZE_WORLD;
      const lw = ORIGIN_MARK_LINEW_WORLD;
      const dotR = ORIGIN_MARK_DOT_WORLD;
      const lineStyle = { stroke: ORIGIN_MARK_COLOR, strokeWidth: lw, selectable:false, evented:false, excludeFromExport:true, objectCaching:false };
      const horiz = new fabric.Line([-L, 0, L, 0], lineStyle);
      const vert  = new fabric.Line([0, -L, 0, L], lineStyle);
      const dot   = new fabric.Circle({ left:0, top:0, radius:dotR, fill:ORIGIN_MARK_COLOR, stroke:null, originX:'center', originY:'center', selectable:false, evented:false, excludeFromExport:true, objectCaching:false });
      const parts = [horiz, vert, dot];
      if (ORIGIN_MARK_HINT){
        parts.push(new fabric.Text('(0,0)', { left:L+6, top:-L-6, fontSize:10, fill:ORIGIN_MARK_COLOR, originX:'left', originY:'bottom', selectable:false, evented:false, excludeFromExport:true, objectCaching:false }));
      }
      originMarker = new fabric.Group(parts, {
        left:0, top:0, originX:'center', originY:'center',
        selectable:false, evented:false, excludeFromExport:true, objectCaching:false
      });
      canvas.add(originMarker);
      // 最背面へ
      const sendFn = canvas.sendObjectToBack?.bind(canvas);
      if (typeof sendFn === 'function') sendFn(originMarker);
      (canvas.requestRenderAll || canvas.renderAll).call(canvas);
    }

    /**
     * 原点マーカーを最背面に維持（他オブジェクト追加後などの保険）
     */
    function keepOriginMarkerBack(){
      if (!originMarker) return;
      const sendFn = canvas.sendObjectToBack?.bind(canvas);
      if (typeof sendFn === 'function') sendFn(originMarker);
    }

    /**
     * 指定スロットにオブジェクトが1つ以上あるか判定する。
     * @param {number} i - スロット番号
     * @returns {boolean} true: データあり / false: 空
     */
    function slotHasData(i){
      const storage_data = localStorage.getItem(LS_KEY_PREFIX + i);
      if (!!storage_data) {
        const parsed = JSON.parse(storage_data);
        return (parsed.objects.length !== 0);
      }
      return false;
    }

    // =========================
    // ビューポート保存/復元ユーティリティ
    // =========================
    /**
     * 画面上の (screenX, screenY) に対応するワールド座標を取得する。
     * @param {number} screenX
     * @param {number} screenY
     * @returns {{x:number,y:number}}
     */
    function getWorldPointAtScreen(screenX, screenY){
      const vt = canvas.viewportTransform || [1,0,0,1,0,0];
      const inv = fabric.util.invertTransform(vt);
      const p = fabric.util.transformPoint(new fabric.Point(screenX, screenY), inv);
      return { x: p.x, y: p.y };
    }
    /**
     * 現在のズームと「画面右上に来ているワールド座標」を保存する。
     * options.touchUpdatedAt === false の時は updatedAt を変更しない（ズーム操作時など）
     * @param {number} slot - 保存先スロット番号
     * @param {{touchUpdatedAt?:boolean}} [options]
     * @returns {void}
     */
    function saveViewportMeta(slot, { touchUpdatedAt = true } = {}){
      try{
        const zoom = canvas.getZoom();
        // ---- 右上は (canvas.width, 0) のスクリーン座標 ----
        const viewTR = getWorldPointAtScreen(canvas.getWidth(), 0);
        // 既存の updatedAt を引き継ぐ（touchUpdatedAt=false の場合）
        let prevUpdated = null;
        try {
          const prevRaw = localStorage.getItem(LS_KEY_META_PREFIX + slot);
          if (prevRaw) prevUpdated = (JSON.parse(prevRaw).updatedAt || null);
        } catch(_){}
        const updatedAt = touchUpdatedAt ? new Date().toISOString() : prevUpdated;
        const meta = { zoom, viewTR, updatedAt };
        localStorage.setItem(LS_KEY_META_PREFIX + slot, JSON.stringify(meta));
      }catch(e){ console.warn('saveViewportMeta failed:', e); }
    }
    /**
     * 保存済みの視点メタを取得する。
     * @param {number} slot
     * @returns {{zoom:number, viewTR:{x:number,y:number}, updatedAt?:string}|null}
     */
    function readViewportMeta(slot){
      try{
        const raw = localStorage.getItem(LS_KEY_META_PREFIX + slot);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed.zoom !== 'number' || !parsed.viewTR) return null;
        return parsed;
      }catch(e){ return null; }
    }
    /**
     * メタ情報に基づき viewportTransform を再設定する。
     * @param {number} slot
     * @returns {void}
     */
    function applyViewportFromMeta(slot){
      const meta = readViewportMeta(slot);
      if (!meta) return;
      const z = meta.zoom;
      if (!z || z <= 0) return;
      const vx = meta.viewTR?.x ?? 0;
      const vy = meta.viewTR?.y ?? 0;
      // 右上 (screenW, 0) が (vx, vy) に一致するように
      const e = canvas.getWidth() - z * vx;
      const f = 0 - z * vy;
      canvas.setViewportTransform([ z, 0, 0, z, e, f ]);
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }

    /** スロットボタンの状態をデータ有無や選択中で更新する。 */
    function refreshSlotButtonsUI(){
      const btns = slotButtonsEl.querySelectorAll('.slot-btn');
      btns.forEach((btn, idx) => {
        const has = slotHasData(idx);
        btn.classList.toggle('active', idx === currentSlot);
        btn.classList.toggle('empty', !has);
        btn.classList.toggle('hasdata', has);
      });
    }

    /**
     * スロットを選択し、内容と視点を読み込む。
     * @param {number} i - スロット番号
     */
    function selectSlot(i){
      currentSlot = Math.max(0, Math.min(SLOT_COUNT-1, i));
      refreshSlotButtonsUI();
      applyingHistory = true;
      loadFromSlot(currentSlot);
      applyingHistory = false;
      resetHistoryBaseline();
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
      canvasEl.focus({preventScroll:true});
      keepOriginMarkerBack();
    }

    // タイトル変更ボタン
    titleBtn.addEventListener('click', () => {
      const cur = getSlotTitle(currentSlot);
      const input = window.prompt(`スロット${currentSlot+1} のタイトルを入力（空で無題）:`, cur ?? '');
      if (input === null) return; // キャンセル
      setSlotTitle(currentSlot, input); // 空文字も許可
      refreshSlotButtonsUI(); //（ボタン表示にタイトルは使っていないが将来拡張に備え）
      if (hoveredSlot === currentSlot && slotPreviewEl.style.display === 'block') showSlotPreview(currentSlot, lastHoverEvent);
    });

    /**
     * スロットボタンを生成し、クリック/プレビューのイベントを付与する。
     */
    function buildSlotButtons(){
      slotButtonsEl.innerHTML = '';
      for (let i=0; i<SLOT_COUNT; i++){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'slot-btn';
        btn.textContent = String(i+1);
        btn.title = `スロット ${i+1}`;
        btn.dataset.slot = String(i);

        btn.addEventListener('click', () => selectSlot(i));

        // ホバー プレビュー
        btn.addEventListener('pointerenter', (e) => {
          hoveredSlot = i; lastHoverEvent = e;
          showSlotPreview(i, e);
        });
        btn.addEventListener('pointermove', (e) => {
          hoveredSlot = i; lastHoverEvent = e;
          showSlotPreview(i, e);
        });
        btn.addEventListener('pointerleave', () => { hoveredSlot = null; hideSlotPreview(); });

        slotButtonsEl.appendChild(btn);
      }
      refreshSlotButtonsUI();
    }

    /**
     * オートセーブを遅延実行でスケジュールする。
     */
    function scheduleAutosave(){
      clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(() => {
        saveToSlot(currentSlot);
      }, AUTOSAVE_DELAY);
    }

    // =========================
    // 変更イベント → 自動保存 & 履歴
    // =========================
    ['object:modified','object:scaled','object:rotated','object:moved'].forEach(evt=>{
      canvas.on(evt, () => { scheduleAutosave(); pushHistoryDebounced(); });
    });

    // =========================
    // Undo / Redo
    // =========================
    const historyStack = [];
    const redoStack = [];
    let applyingHistory = false;
    let historyTimer = null;

    /**
     * 現在のキャンバス状態スナップショット（JSON文字列）を取得。
     * @returns {string}
     */
    function getCanvasSnapshot(){ return exportCanvasJSON(); }
    /**
     * スナップショットをキャンバスへ適用する。
     * @param {string} json - JSON 文字列
     */
    function applySnapshot(json){
      applyingHistory = true;
      canvas.clear();
      setCanvasBg('#ffffff');
      importCanvasJSON(json, () => {
        applyingHistory = false;
        // 原点マーカーを復元し最背面へ
        ensureOriginMarker(); keepOriginMarkerBack();
        (canvas.requestRenderAll || canvas.renderAll).call(canvas);
      });
    }
    /** 履歴に現在スナップショットを積む（重複は抑止） */
    function pushHistory(){
      if (applyingHistory) return;
      const snap = getCanvasSnapshot();
      if (historyStack.length && historyStack[historyStack.length-1] === snap) return;
      historyStack.push(snap);
      if (historyStack.length > HISTORY_LIMIT) historyStack.shift();
      redoStack.length = 0;
    }
    /** 短時間の改変を 1 つにまとめるためのデバウンス push */
    function pushHistoryDebounced(){
      if (applyingHistory) return;
      clearTimeout(historyTimer);
      historyTimer = setTimeout(() => pushHistory(), 200);
    }

    /**
     * 履歴のベースラインを再作成する。
     * - undo/redo スタックをクリア
     * - 現在状態のスナップショットを 1 件だけ積む
     * @returns {void}
     */
    function resetHistoryBaseline(){
      // 既存の履歴を破棄
      historyStack.length = 0;
      redoStack.length = 0;
      pushHistory(); // 現在の状態をベースラインとして登録
    }

    /** Undo 操作 */
    function undo(){
      if (historyStack.length <= 1) return;
      const cur = historyStack.pop();
      const prev = historyStack[historyStack.length-1];
      redoStack.push(cur);
      applySnapshot(prev);
    }
    /** Redo 操作 */
    function redo(){
      if (!redoStack.length) return;
      const next = redoStack.pop();
      historyStack.push(next);
      applySnapshot(next);
    }

    // （canvas描画フックによる原点描画は廃止。ワールド固定オブジェクトで実現）

    // =========================
    // サムネプレビュー
    // =========================
    const slotThumbCache = new Map(); // cacheKey(slotIndex|updatedAt) -> dataURL
    let hoveredSlot = null;
    let lastHoverEvent = null;
    let shiftHeld = false;

    /** スロットボタン上に表示するプレビューを消去 */
    function hideSlotPreview(){
      slotPreviewEl.style.display = 'none';
      // 古いサムネが残るのを防止
      slotPreviewImg.removeAttribute('src');
      slotPreviewTitle.textContent = '';
      slotPreviewMeta.textContent  = '';
    }
    /**
     * プレビューの表示位置をマウス座標に合わせて更新する。
     * @param {PointerEvent|MouseEvent} e
     */
    function positionSlotPreview(e){
      if (!e) return;
      slotPreviewEl.style.left = e.clientX + 'px';
      slotPreviewEl.style.top  = e.clientY + 'px';
    }

    // Shift “後押し”にも対応
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Shift'){ shiftHeld = true; if (hoveredSlot!==null) showSlotPreview(hoveredSlot, lastHoverEvent||e); }
    }, true);
    window.addEventListener('keyup', (e) => {
      if (e.key === 'Shift'){ shiftHeld = false; hideSlotPreview(); }
    }, true);

    /**
     * スロットボタン上のプレビューを表示する。
     * - サムネはキャッシュ（slotIndex|updatedAt）を利用
     * - 未キャッシュ時は生成してから表示
     * @param {number} slotIndex
     * @param {PointerEvent|MouseEvent} e
     */
    function showSlotPreview(slotIndex, e){
      if (!slotHasData(slotIndex)) { hideSlotPreview(); return; }

      // ここで枠を先に出す（画像は未セットのまま）
      positionSlotPreview(e);
      // タイトル取得（null=未設定, ""=無題）
      const t = getSlotTitle(slotIndex);
      // if (t === null){
      //   slotPreviewCaption.textContent = `スロット ${slotIndex+1}`;
      // }else{
      //   slotPreviewCaption.textContent = t === '' ? `スロット ${slotIndex+1}` : t;
      // }
      if (t === null) slotPreviewTitle.textContent = `スロット ${slotIndex+1}`;
      else            slotPreviewTitle.textContent = (t === '' ? `スロット ${slotIndex+1}` : t);
      slotPreviewImg.removeAttribute('src'); // 古い残像を消す
      // 最終更新（下部へ表示）
      const metaRaw = localStorage.getItem(LS_KEY_META_PREFIX + slotIndex);
      let updatedAt = null;
      try { updatedAt = metaRaw ? (JSON.parse(metaRaw).updatedAt || null) : null; } catch(_){}
      slotPreviewMeta.textContent = '最終更新: ' + formatDateLabel(updatedAt);
      slotPreviewEl.style.display = 'block';

      // 保存データとメタ（更新日時）を取得
      const json = localStorage.getItem(LS_KEY_PREFIX + slotIndex);
      // キャッシュキーは更新日時も含めてOK（内容が変われば画像も作り直す）
      const cacheKey = `${slotIndex}|${updatedAt || 'none'}`;

      // ---- キャッシュがあれば即表示 ----
      const cached = slotThumbCache.get(cacheKey);
      if (cached){
        slotPreviewImg.src = cached;
        return; // 既に枠は表示済み
      }
      if (!json){ hideSlotPreview(); return; }

      // ベースのサムネを生成後、更新日バッジを重ね描き
      // 純粋なサムネ（画像のみ）を生成
      generateThumbnailFromJSON(json, PREVIEW_W, PREVIEW_H).then((dataURL) => {
        slotThumbCache.set(cacheKey, dataURL);
        // すでに枠は出ているので src を付け替えるだけ
        slotPreviewImg.src = dataURL;
      }).catch(() => {
        hideSlotPreview();
      });
    }

    /**
     * 既存のサムネ生成結果へ「最終更新」バッジを重ねて返す。
     * @param {string} jsonText - Fabric JSON 文字列
     * @param {string|null} updatedAtISO - ISO 形式の更新日時
     * @param {number} [w=PREVIEW_W]
     * @param {number} [h=PREVIEW_H]
     * @returns {Promise<string>} dataURL
     */
    async function generateThumbnailWithUpdatedAt(jsonText, updatedAtISO, w=PREVIEW_W, h=PREVIEW_H){
      const baseURL = await generateThumbnailFromJSON(jsonText, w, h);
      // 合成用キャンバス
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d');
      await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { ctx.drawImage(img, 0, 0, w, h); resolve(); };
        img.onerror = reject;
        img.src = baseURL;
      });
      drawUpdatedAtBadge(c, updatedAtISO);
      return c.toDataURL('image/png');
    }
    // ↑ 現在は使用しません（下部テキスト表示に移行）。必要があれば将来のために残置。

    /**
     * スロットボタン上にポップアップ表示するサムネイルを生成する。
     * v6 の Promise 返却に対応。旧版（callback）でも自動フォールバック。
     * @param {string|object} jsonText - Fabric JSON（文字列 or オブジェクト）
     * @param {number} [targetW=PREVIEW_W]
     * @param {number} [targetH=PREVIEW_H]
     * @returns {Promise<string>} dataURL
     */
    async function generateThumbnailFromJSON(jsonText, targetW = PREVIEW_W, targetH = PREVIEW_H) {
      return new Promise(async (resolve, reject) => {
        try {
          // ★ blob: 画像を除去してから生成
          // ---- オフスクリーン StaticCanvas 準備（null は渡さない）----
          const offscreen = document.createElement('canvas');
          offscreen.width = targetW;
          offscreen.height = targetH;

          const sc = new fabric.StaticCanvas(offscreen, {
            width: targetW, height: targetH, backgroundColor: '#ffffff',
            enableRetinaScaling: false, renderOnAddRemove: false
          });

          let parsed = (typeof jsonText === 'string') ? JSON.parse(jsonText) : jsonText;
          // 既存データの blob:null 画像を除去
          parsed = sanitizeFabricJSON(parsed);
          const objsRaw = Array.isArray(parsed?.objects) ? parsed.objects : [];

          // 背景
          const bg = parsed.backgroundColor || parsed.background || '#ffffff';
          // sc.setBackgroundColor(bg, sc.renderAll.bind(sc));

          if (!objsRaw.length) {
            sc.renderAll();
            return resolve(offscreen.toDataURL('image/png'));
          }

          // 画像対策 reviver
          const reviver = (orig, obj) => {
            if (obj && obj.type === 'image' && !obj.crossOrigin) obj.crossOrigin = 'anonymous';
          };

          // v6: Promise / 旧版: callback 両対応
          let enlivened;
          const maybePromise = fabric.util.enlivenObjects(objsRaw, { reviver });
          if (maybePromise && typeof maybePromise.then === 'function') {
            enlivened = await maybePromise;
          } else {
            return fabric.util.enlivenObjects(
              objsRaw,
              (arr) => {
                try {
                  arr.forEach(o => sc.add(o));
                  sc.renderAll();
                  const url = _fitAndSnapshot(sc, targetW, targetH);
                  resolve(url);
                } catch (e) { reject(e); }
              },
              null,
              reviver
            );
          }

          enlivened.forEach(o => sc.add(o));
          sc.renderAll();

          const url = _fitAndSnapshot(sc, targetW, targetH);
          resolve(url);

        } catch (e) {
          reject(e);
        }
      });

      /**
       * 内部ヘルパー: 外接矩形にフィットさせて PNG を返す。
       * @param {fabric.StaticCanvas} sc
       * @param {number} targetW
       * @param {number} targetH
       * @returns {string} dataURL
       */
      function _fitAndSnapshot(sc, targetW, targetH) {
        const objs = sc.getObjects();
        if (!objs.length) {
          sc.renderAll();
          return sc.getElement().toDataURL('image/png');
        }
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const o of objs) {
          const br = o.getBoundingRect(true, true);
          minX = Math.min(minX, br.left);
          minY = Math.min(minY, br.top);
          maxX = Math.max(maxX, br.left + br.width);
          maxY = Math.max(maxY, br.top  + br.height);
        }
        const pad = FIT_PAD;
        const contentW = Math.max(1, (maxX - minX));
        const contentH = Math.max(1, (maxY - minY));
        const sx = (targetW - pad * 2) / contentW;
        const sy = (targetH - pad * 2) / contentH;
        const s  = Math.min(sx, sy);
        const tx = (-minX) * s + pad;
        const ty = (-minY) * s + pad;

        sc.setViewportTransform([ s, 0, 0, s, tx, ty ]);
        sc.renderAll();

        // StaticCanvas に渡した実体 canvas から取得
        return sc.getElement().toDataURL('image/png');
      }
    }

    // =========================
    // 更新日描画ユーティリティ
    // =========================
    /**
     * プレビュー画像の右下に「最終更新: yyyy/MM/dd hh:mm」バッジを描画。
     * @param {HTMLCanvasElement} canvasEl
     * @param {string|null} updatedAtISO
     */
    function drawUpdatedAtBadge(canvasEl, updatedAtISO){
      const ctx = canvasEl.getContext('2d');
      const text = '最終更新: ' + formatDateLabel(updatedAtISO);
      // 現在は未使用：画像へのバッジ描画は廃止し、枠下部にテキスト表示へ移行
      ctx.font = BADGE_FONT;
      const padX = BADGE_PAD_X;
      const padY = BADGE_PAD_Y;
      // 影響が少ないように事前にメジャー
      const metrics = ctx.measureText(text);
      const w = metrics.width + padX * 2;
      const h = 18 + padY * 2;
      const x = canvasEl.width  - w - BADGE_MARGIN;
      const y = canvasEl.height - h - BADGE_MARGIN;

      // 背景（角丸・白半透明）
      ctx.fillStyle = BADGE_BG;
      roundRect(ctx, x, y, w, h, BADGE_RADIUS);
      ctx.fill();
      // 枠線
      ctx.strokeStyle = BADGE_BORDER;
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, w, h, BADGE_RADIUS);
      ctx.stroke();
      // 文字
      ctx.fillStyle = BADGE_TEXT;
      ctx.fillText(text, x + padX, y + padY + 13);
    }
    /**
     * 角丸矩形パスを生成する。
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {number} w
     * @param {number} h
     * @param {number} r
     */
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    /**
     * ISO 文字列を「yyyy/MM/dd hh:mm」に整形する。
     * @param {string|null} iso
     * @returns {string}
     */
    function formatDateLabel(iso){
      if (!iso) return '(不明)';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return '(不明)';
      const y  = d.getFullYear();
      const m  = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${y}/${m}/${dd} ${hh}:${mm}`;
    }

    // =========================
    // 出力用ユーティリティ（ファイル名）
    // =========================
    /**
     * 現在日時を yyyymmdd_hhmmss で返す（ローカル時刻）。
     * @returns {string}
     */
    function formatNowForFilename(){
      const d = new Date();
      const y  = d.getFullYear();
      const m  = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      const ss = String(d.getSeconds()).padStart(2,'0');
      return `${y}${m}${dd}_${hh}${mm}${ss}`;
    }
    /**
     * スロットタイトルをファイル名向けに取得（未設定/空白は「スロットn」）
     * ファイル名に使えない文字は _ に置換。
     * @param {number} slot
     * @returns {string}
     */
    function getSafeTitleForFilename(slot){
      const t = getSlotTitle(slot);
      const base = (t === null || String(t).trim() === '') ? `スロット${slot+1}` : String(t).trim();
      return base.replace(/[\\\/:*?"<>|]/g, '_');
    }

    // =========================
    // 既存描画（要点）
    // =========================
    const groupOptions = { hasControls:true, hoverCursor:'move', originX:'left', originY:'top', opacity:1, objectCaching:false };

    function centerGroupLabel(group){
      if (!group || !group._label) return;
      const br = group.getBoundingRect(true, true);
      const centerCanvas = new fabric.Point(br.left + br.width/2, br.top + br.height/2);
      const m  = group.calcTransformMatrix();
      const im = fabric.util.invertTransform(m);
      const centerLocal = fabric.util.transformPoint(centerCanvas, im);
      group._label.set({ originX:'center', originY:'center', left:centerLocal.x, top:centerLocal.y, textAlign:'center' });
      group.setCoords();
    }
    function createLabeledGroup(baseObjects){
      const dropPoint = getDropPoint();
      const labelText = new fabric.Text('', { fontSize:16, fill:'#0f172a', originX:'center', originY:'center', top:0, left:0, textAlign:'center', objectCaching:false });
      baseObjects.forEach(o => o.set({ objectCaching:false, globalCompositeOperation:'source-over' }));
      const group = new fabric.Group([...baseObjects, labelText], { ...groupOptions, left: dropPoint.x, top: dropPoint.y, globalCompositeOperation:'source-over' });
      group._label = labelText;
      canvas.add(group);
      centerGroupLabel(group);
      canvas.setActiveObject(group);
      if (canvas.bringToFront) canvas.bringToFront(group);
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
      return group;
    }
    function addCircle(){
      const circle = new fabric.Circle({ left:0, top:0, radius:60, fill:'#22c55e', stroke:'#22c55e', strokeWidth:3, strokeUniform:true });
      createLabeledGroup([circle]);
    }
    function addRect(){
      const rect = new fabric.Rect({ left:0, top:0, width:150, height:100, rx:8, ry:8, fill:'#60a5fa', stroke:'#60a5fa', strokeWidth:3, strokeUniform:true });
      createLabeledGroup([rect]);
    }
    function addTextBox(){
      const drop = getDropPoint();
      const nextText = window.prompt('テキストを入力してください：', '');
      if (nextText === null) return;
      const tb = new fabric.Textbox(nextText, { left: drop.x, top: drop.y, fontSize:18, fill:'#0f172a', textAlign:'left', objectCaching:false });
      canvas.add(tb);
      canvas.setActiveObject(tb);
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
    }

    // ===== 直線/矢印 共通描画ステート =====
    // mode: 'arrow' | 'line'
    const strokeDraw = {
      mode: null,
      start: null,
      dashed: false,
      preview: null,   // fabric.Line
      head: null       // fabric.Triangle (arrow のみ)
    };

    /** 直線/矢印 描画開始（共通） */
    function startStrokeDrawing({ mode, dashed = false } = {}){
      // 既存プレビューの掃除
      if (strokeDraw.preview){ canvas.remove(strokeDraw.preview); strokeDraw.preview = null; }
      if (strokeDraw.head){ canvas.remove(strokeDraw.head); strokeDraw.head = null; }
      strokeDraw.mode = mode;                 // 'arrow' or 'line'
      strokeDraw.dashed = !!dashed;
      const start = getDropPoint();
      strokeDraw.start = { x: start.x, y: start.y };
      // 共通のプレビュー線
      strokeDraw.preview = new fabric.Line([start.x, start.y, start.x, start.y], {
        stroke: line_param.stroke,
        strokeWidth: line_param.strokeWidth,
        strokeLineCap: line_param.strokeLineCap,
        opacity: .6, selectable:false, evented:false,
        strokeDashArray: (strokeDraw.dashed ? [8,6] : null)
      });
      canvas.add(strokeDraw.preview);
      // 矢印なら頭も
      if (mode === 'arrow'){
        strokeDraw.head = new fabric.Triangle({
          left:start.x, top:start.y, width:arrow_param.width, height:arrow_param.height, angle:0,
          fill:arrow_param.fill, stroke:arrow_param.stroke, strokeWidth:arrow_param.strokeWidth,
          originX:arrow_param.originX, originY:arrow_param.originY, selectable:false, evented:false
        });
        canvas.add(strokeDraw.head);
      }
      canvas.bringToFront && canvas.bringToFront(strokeDraw.preview);
      canvas.renderAll();
    }

    /**
     * 矢印プレビューの終点スナップ（水平/垂直）
     * - 判定は「画面ピクセル」でのズレ量を基準にし、ズームに依らず一定の体感にする
     * - 始点 start と現在座標 pos から、水平or垂直に近い方へスナップした座標を返す
     * - 両方閾値内の場合は「より近い軸」にスナップ
     * @param {{x:number,y:number}} start  ワールド座標の始点
     * @param {{x:number,y:number}} pos    ワールド座標の現在位置
     * @returns {{x:number,y:number}} スナップ後の終点（ワールド座標）
     */
    function snapArrowEndpointHV(start, pos){
      // 画面ピクセル→ワールドの換算はズーム倍率で近似
      const z = canvas.getZoom() || 1;
      const tolWorld = ARROW_SNAP_TOL_PX / z;

      const dx = pos.x - start.x;
      const dy = pos.y - start.y;
      const adx = Math.abs(dx);
      const ady = Math.abs(dy);

      const snapH = (ady <= tolWorld); // 水平（y を揃える）
      const snapV = (adx <= tolWorld); // 垂直（x を揃える）

      if (!snapH && !snapV) return pos;

      // 両方内なら、より小さい誤差の軸を優先
      if (snapH && snapV){
        if (ady <= adx){
          return { x: pos.x, y: start.y }; // 水平優先
        }else{
          return { x: start.x, y: pos.y }; // 垂直優先
        }
      }
      if (snapH) return { x: pos.x, y: start.y };
      // snapV
      return { x: start.x, y: pos.y };
    }

    function calcurateArrowDegree(x1, y1, x2, y2) { return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI; }

    /** プレビュー更新（共通） */
    function updateStrokePreview(){
      if (!strokeDraw.mode || !strokeDraw.preview || !strokeDraw.start) return;
      const raw = getDropPoint();
      // 水平/垂直スナップ
      const end = snapArrowEndpointHV(strokeDraw.start, raw)
      strokeDraw.preview.set({ x2: end.x, y2: end.y });
      if (strokeDraw.head){
        strokeDraw.head.set({ left:end.x, top:end.y });
        strokeDraw.head.set({ angle: calcurateArrowDegree(strokeDraw.preview.x1, strokeDraw.preview.y1, end.x, end.y) + 90 });
      }
      strokeDraw.preview.setCoords();
      strokeDraw.head && strokeDraw.head.setCoords();
      canvas.renderAll();
    }

    /** 確定（共通） */
    function finalizeStrokeDrawingIfNeeded(domEvent){
      if (!strokeDraw.mode || !strokeDraw.start) return false;
      const hasPreview = !!strokeDraw.preview;
      const x1 = hasPreview ? strokeDraw.preview.x1 : strokeDraw.start.x;
      const y1 = hasPreview ? strokeDraw.preview.y1 : strokeDraw.start.y;
      const p  = canvas.getPointer(domEvent);
      const x2 = hasPreview ? strokeDraw.preview.x2 : p.x;
      const y2 = hasPreview ? strokeDraw.preview.y2 : p.y;

      if (strokeDraw.mode === 'line'){
        const plain = new fabric.Line([x1, y1, x2, y2], {
          stroke: line_param.stroke,
          strokeWidth: line_param.strokeWidth,
          strokeLineCap: line_param.strokeLineCap,
          strokeDashArray: (strokeDraw.dashed ? [8,6] : null)
        });
        canvas.add(plain);
        canvas.setActiveObject(plain);
        // プレビュー片付け
        if (strokeDraw.preview){ canvas.remove(strokeDraw.preview); strokeDraw.preview = null; }
        if (strokeDraw.head){ canvas.remove(strokeDraw.head); strokeDraw.head = null; }
        strokeDraw.mode = null; strokeDraw.start = null; strokeDraw.dashed = false;
        canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
        scheduleAutosave(); pushHistory(); return true;
      }

      // --- 矢印 ---
      // 1) プレビューと同じ絶対座標で一旦「素オブジェクト」を作成し、線＋矢印頭の外接矩形を取得
      const angleDeg = calcurateArrowDegree(x1, y1, x2, y2);
      const tmpLine = new fabric.Line([x1, y1, x2, y2], {
        stroke: line_param.stroke,
        strokeWidth: line_param.strokeWidth,
        strokeLineCap: line_param.strokeLineCap,
        strokeDashArray: (strokeDraw.dashed ? [8,6] : null),
        selectable:false, evented:false
      });
      const tmpHead = new fabric.Triangle({
        left:x2, top:y2,
        width:arrow_param.width, height:arrow_param.height,
        angle:angleDeg + 90,
        fill:arrow_param.fill, stroke:arrow_param.stroke, strokeWidth:arrow_param.strokeWidth,
        originX:arrow_param.originX, originY:arrow_param.originY,
        selectable:false, evented:false
      });
      const brL = tmpLine.getBoundingRect(true, true);
      const brH = tmpHead.getBoundingRect(true, true);
      const minX = Math.min(brL.left, brH.left);
      const minY = Math.min(brL.top , brH.top );
      const p1 = { x: x1 - minX, y: y1 - minY };
      const p2 = { x: x2 - minX, y: y2 - minY };

      // 2) 正規化した相対座標で最終オブジェクトを作り直す
      const shaftLine = new fabric.Line(
        [p1.x, p1.y, p2.x, p2.y],
        {
          stroke: line_param.stroke,
          strokeWidth: line_param.strokeWidth,
          strokeLineCap: line_param.strokeLineCap,
          // strokeDashArray: (pendingLineDashed ? [8,6] : null)
          strokeDashArray: (strokeDraw.dashed ? [8,6] : null)
        }
      );
      const arrowHead = new fabric.Triangle(
        {
          left:p2.x, top:p2.y,
          width:arrow_param.width, height:arrow_param.height,
          angle:angleDeg + 90,
          fill:arrow_param.fill, stroke:arrow_param.stroke, strokeWidth:arrow_param.strokeWidth,
          originX:arrow_param.originX, originY:arrow_param.originY
        }
      );

      // 3) 線と矢印頭を含めた「全体の左上(minX,minY)」にグループを配置
      const arrowGroup = new fabric.Group([shaftLine, arrowHead], {
        ...groupOptions,
        left: minX,
        top : minY
      });

      canvas.add(arrowGroup);
      canvas.setActiveObject(arrowGroup);

      // プレビュー片付け
      if (strokeDraw.preview){ canvas.remove(strokeDraw.preview); strokeDraw.preview = null; }
      if (strokeDraw.head){ canvas.remove(strokeDraw.head); strokeDraw.head = null; }
      strokeDraw.mode = null; strokeDraw.start = null; strokeDraw.dashed = false;

      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      scheduleAutosave();
      pushHistory();
      return true;
    }

    /** プレビューキャンセル（共通） */
    function cancelStrokePreview(render){
      if (strokeDraw.preview){ canvas.remove(strokeDraw.preview); strokeDraw.preview = null; }
      if (strokeDraw.head){ canvas.remove(strokeDraw.head); strokeDraw.head = null; }
      strokeDraw.mode = null;
      strokeDraw.start = null;
      strokeDraw.dashed = false;
      if (render) canvas.renderAll();
    }

    /**
     * ビューポートをパン（スクロール）するヘルパー
     * @param {number} dx - 画面座標系のX方向移動量（px）
     * @param {number} dy - 画面座標系のY方向移動量（px）
     */
    function panViewport(dx, dy){
      const vt = canvas.viewportTransform || [1,0,0,1,0,0];
      // vt = [a, b, c, d, e, f] -> e,f が平行移動
      const a = vt[0], b = vt[1], c = vt[2], d = vt[3];
      let  e = vt[4], f = vt[5];
      // 画面座標の移動量をそのまま e,f に加算（fabricは画面→世界の変換を内部で考慮）
      e += dx;
      f += dy;
      canvas.setViewportTransform([a,b,c,d,e,f]);
      (canvas.requestRenderAll || canvas.renderAll).call(canvas);
      saveViewportMeta(currentSlot, { touchUpdatedAt:false });
    }

    // =========================
    // システムクリップボード（画像）貼り付け
    // =========================
    /**
     * クリップボードから画像を取得してキャンバスへ貼り付ける。
     * - navigator.clipboard.read() を利用（HTTPS/ユーザー操作前提）
     * - PNG/JPEG の最初の画像を使用
     * @param {{x:number,y:number}} dropPoint - 貼り付けるキャンバス座標
     */
    async function pasteImageFromClipboardAt(dropPoint){
      // ブラウザ対応確認
      if (!navigator.clipboard || typeof navigator.clipboard.read !== 'function'){
        alert('このブラウザではクリップボードからの画像貼り付け（Ctrl+Shift+V）に対応していません。');
        return;
      }
      try{
        const items = await navigator.clipboard.read();
        // ClipboardItem の中から画像タイプを探す
        let imageBlob = null;
        outer: for (const item of items){
          // types は MIME の配列。優先順に探す
          const types = Array.isArray(item.types) ? item.types : [];
          const preferred = ['image/png','image/jpeg','image/jpg','image/webp'];
          for (const mime of preferred){
            if (types.includes(mime)){
              imageBlob = await item.getType(mime);
              break outer;
            }
          }
          // 汎用的に image/* を走査
          if (!imageBlob){
            for (const t of types){
              if (t.startsWith('image/')){
                imageBlob = await item.getType(t);
                break outer;
              }
            }
          }
        }
        if (!imageBlob){
          alert('クリップボードに画像が見つかりませんでした。');
          return;
        }
        // ★ Blob → DataURL 化（保存/復元に強い）
        const dataURL = await new Promise((res, rej) => {
          const fr = new FileReader();
          fr.onload = () => res(String(fr.result||''));
          fr.onerror = (e) => rej(e);
          fr.readAsDataURL(imageBlob);
        });
        try {
          const img = await fabric.Image.fromURL(dataURL); // v6: Promise API
          // スケール（キャンバスの 60% を上限）
          const maxW = canvas.getWidth() * 0.6;
          const maxH = canvas.getHeight() * 0.6;
          // 画像の自然サイズ（width/height は fromURL 解決後に利用可）
          const iw = img.width || 1;
          const ih = img.height || 1;
          const scale = Math.min(1, maxW / iw, maxH / ih);
          img.set({
            originX: 'center',
            originY: 'center',
            left: dropPoint.x,
            top: dropPoint.y,
            scaleX: scale,
            scaleY: scale,
            objectCaching: false
          });
          canvas.add(img);
          canvas.setActiveObject(img);
          (canvas.requestRenderAll || canvas.renderAll).call(canvas);
          scheduleAutosave();
          pushHistory();
        } catch (e) {
          console.warn('fabric.Image.fromURL failed:', e);
          alert('画像の貼り付けに失敗しました（fromURL）。ブラウザの制限やクリップボードの内容をご確認ください。');
        // } finally {
        //   URL.revokeObjectURL(url);
        }
      }catch(err){
        console.warn('clipboard image paste failed:', err);
        alert('クリップボードからの画像取得に失敗しました。ブラウザの権限設定や HTTPS での実行をご確認ください。');
      }
    }

    // =========================
    // コピー / カット / ペースト（スロット跨ぎ対応）
    // =========================
    /**
     * オブジェクト配列の外接矩形（キャンバス座標）を取得
     * @param {fabric.Object[]} objs
     * @returns {{minX:number,minY:number,maxX:number,maxY:number,width:number,height:number}}
     */
    // computeBounds は既存のまま

    /**
     * 選択オブジェクト群の外接矩形を求める
     * @param {fabric.Object[]} objs
     * @returns {{minX:number,minY:number,maxX:number,maxY:number,width:number,height:number}}
     */
    function computeBounds(objs){
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const o of objs){
        const br = o.getBoundingRect(true, true);
        minX = Math.min(minX, br.left);
        minY = Math.min(minY, br.top);
        maxX = Math.max(maxX, br.left + br.width);
        maxY = Math.max(maxY, br.top  + br.height);
      }
      const width  = Math.max(0, maxX - minX);
      const height = Math.max(0, maxY - minY);
      return { minX, minY, maxX, maxY, width, height };
    }

    /**
     * 選択中オブジェクトを localStorage へ保存（コピー/カット）
     * @param {boolean} cut - true でカット（元オブジェクトを削除）
     */
    function copySelectionToClipboard(cut = false){
      const selected = canvas.getActiveObjects();
      if (!selected || !selected.length) return;

      // ActiveSelection を展開せず素の配列で扱う
      const bounds = computeBounds(selected); // 選択全体の外接矩形
      const items = selected.map(o => {
        // 1) シリアライズ
        const raw = o.toObject();
        // 2) そのオブジェクト自身の外接矩形（left/top は origin に依存するため使わない）
        const br = o.getBoundingRect(true, true);
        // 3) 選択全体の左上からの相対量（＝外接矩形ベース）
        const brDx = br.left - bounds.minX;
        const brDy = br.top  - bounds.minY;
        return { raw, brDx, brDy };
      });

      const clip = {
        type: 'wb_clip_v1',
        // w: bounds.width,
        // h: bounds.height,
        // w/h は過去互換のため残すが、今回の貼り付け位置決定には使わない
        w: bounds.width,
        h: bounds.height,
        items
      };
      try{
        localStorage.setItem(CLIPBOARD_KEY, JSON.stringify(clip));
      }catch(e){ console.warn('clipboard write failed:', e); }

      if (cut){
        // 元を削除
        selected.forEach(o => canvas.remove(o));
        canvas.discardActiveObject();
        const render = canvas.requestRenderAll || canvas.renderAll;
        render.call(canvas);
        scheduleAutosave();
        pushHistory();
      }
    }

    /**
     * クリップボードの内容をカーソル位置へ貼り付け
     * @param {{x:number,y:number}} point - キャンバス座標（getDropPoint() 推奨）
     */
    function pasteClipboardAt(point){
      let data = null;
      try{
        const raw = localStorage.getItem(CLIPBOARD_KEY);
        if (raw) data = JSON.parse(raw);
      }catch(e){ console.warn('clipboard read failed:', e); }
      if (!data || data.type !== 'wb_clip_v1' || !Array.isArray(data.items) || !data.items.length) return;

      const dropX = point.x, dropY = point.y; // ここを「貼り付け塊の左上」にする

      // enlivenObjects で再生成（画像なども含む）
      const objsRaw = data.items.map(it => it.raw);
      const reviver = (orig, obj) => {
        if (obj && obj.type === 'image' && !obj.crossOrigin) obj.crossOrigin = 'anonymous';
      };
      const maybePromise = fabric.util.enlivenObjects(objsRaw, { reviver });

      const handleEnlivened = (arr) => {
        const pasted = [];
        for (let i=0; i<arr.length; i++){
          const o = arr[i];
          const meta = data.items[i];

          // --- フォールバック対応 ---
          // 新: brDx/brDy（外接矩形基準） / 旧: dx/dy（left/top基準）
          const hasBR = typeof meta.brDx === 'number' && typeof meta.brDy === 'number';

          if (hasBR){
            // 1) 現在の外接矩形
            const br = o.getBoundingRect(true, true);
            // 2) このオブジェクトの外接矩形の「狙い位置」
            const desiredLeft = dropX + meta.brDx;
            const desiredTop  = dropY + meta.brDy;
            // 3) 外接矩形ベースで差分移動（回転や origin の違いを吸収）
            const deltaX = desiredLeft - br.left;
            const deltaY = desiredTop  - br.top;
            o.set({
              left: (o.left || 0) + deltaX,
              top : (o.top  || 0) + deltaY
            });
          } else {
            // 旧フォーマット: dx/dy は left/top 基準（ズレるケースがあるが後方互換のため残す）
            const offX = dropX;
            const offY = dropY;
            o.set({
              left: offX + (meta.dx || 0),
              top : offY + (meta.dy || 0)
            });
          }

          o.setCoords && o.setCoords();
          canvas.add(o);
          pasted.push(o);
        }

        if (pasted.length){
          const sel = new fabric.ActiveSelection(pasted, { canvas });
          canvas.setActiveObject(sel);
        }
        const render = canvas.requestRenderAll || canvas.renderAll;
        render.call(canvas);
        scheduleAutosave();
        pushHistory();
      };

      if (maybePromise && typeof maybePromise.then === 'function'){
        maybePromise.then(handleEnlivened).catch(err => console.error('paste failed:', err));
      }else{
        // 旧 API 互換
        fabric.util.enlivenObjects(
          objsRaw,
          (arr) => { try{ handleEnlivened(arr); }catch(e){ console.error('paste failed:', e); } },
          null,
          reviver
        );
      }
    }

    // =========================
    // 操作ユーティリティ
    // =========================
    /**
     * スペースで色変更：
     * - 単体 Line は stroke を変更
     * - 単体の図形/テキスト/画像は fill（stroke を持つ場合は stroke も）を変更
     * - 矢印（Line + Triangle のグループ）は line.stroke と tri.fill/tri.stroke を同期して変更
     * @param {fabric.Object} obj
     */
    function cycleFillColor(obj){
      if (!obj) return;

      // パレット中の「次の色」を返す（見つからない場合は 0 番を返す）
      const nextColor = (cur) => {
        const s   = (cur || '').toString();
        const idx = color_palette.indexOf(s);
        const i   = idx >= 0 ? (idx + 1) % color_palette.length : 0;
        return color_palette[i];
      };

      // ---- グループ（矢印など） ----
      if (obj.type === 'group' && Array.isArray(obj._objects)){
        const line  = obj._objects.find(o => o.type === 'line');
        const tri   = obj._objects.find(o => o.type === 'triangle');
        const shape = obj._objects.find(o => ['rect','circle','path','textbox','text'].includes(o.type));

        // 矢印（line+triangle）: 同一色で統一
        if (line || tri){
          const base = (tri && (tri.fill || tri.stroke))
                    || (line && line.stroke)
                    || (shape && (shape.fill || shape.stroke))
                    || color_palette[0];
          const next = nextColor(base);
          if (line) line.set({ stroke: next });
          if (tri)  tri.set({ fill: next, stroke: next });
          // 他に図形が入っている場合も合わせる（あれば）
          if (shape){
            shape.set({ fill: next });
            if ('stroke' in shape && shape.stroke !== null) shape.set({ stroke: next });
          }
          obj.setCoords && obj.setCoords();
          canvas.renderAll();
          return;
        }

        // 通常のグループ：代表シェイプの色を回す
        if (shape){
          const base = shape.fill || shape.stroke || color_palette[0];
          const next = nextColor(base);
          shape.set({ fill: next });
          if ('stroke' in shape && shape.stroke !== null) shape.set({ stroke: next });
          obj.setCoords && obj.setCoords();
          canvas.renderAll();
          return;
        }
        // group だが該当なし → 以降の通常処理へフォールバック
      }

      // ---- 単体オブジェクト ----
      if (obj.type === 'line'){
        const base = obj.stroke || color_palette[0];
        const next = nextColor(base);
        obj.set({ stroke: next });
      }else if (obj.type === 'triangle'){
        // 単体三角形（念のため）
        const base = obj.fill || obj.stroke || color_palette[0];
        const next = nextColor(base);
        obj.set({ fill: next, stroke: next });
      }else{
        // 図形/テキスト/画像など
        const base = obj.fill || obj.stroke || color_palette[0];
        const next = nextColor(base);
        obj.set({ fill: next });
        if ('stroke' in obj && obj.stroke !== null) obj.set({ stroke: next });
      }
      obj.setCoords && obj.setCoords();
      canvas.renderAll();
    }

    function editLabelByDblClick(targetObject){
      if (!targetObject) return;
      const group = (targetObject.type === 'group') ? targetObject : targetObject.group;
      const isTextOnly = (targetObject.type === 'textbox' || targetObject.type === 'text');
      let labelText = null;

      if (group){
        labelText = group._label || (group._objects ? group._objects.find(o=>o.type==='text') : null);
        if (!labelText) return;
      }else if (isTextOnly){
        labelText = targetObject;
      }else return;

      const currentText = labelText.text || '';
      const nextText = window.prompt('図形のテキストを入力してください：', currentText);
      if (nextText === null) return;

      // labelText.set({ text: nextText, textAlign:'center', originX:'center', originY:'center' });
      labelText.set({ text: nextText, textAlign:'center' });
      if (group){ centerGroupLabel(group); }
      (group || labelText).setCoords();
      canvas.renderAll();
    }
    function nudgeObject(obj, dx, dy){
      obj.set({ left: (obj.left||0)+dx, top: (obj.top||0)+dy });
      obj.setCoords();
      canvas.renderAll();
    }

    function duplicateObject(obj){
      // 現在の選択を優先、なければ引数 obj を対象にする
      let targets = canvas.getActiveObjects();
      if (!targets || !targets.length){
        if (!obj) return;
        targets = [obj];
        canvas.setActiveObject(obj);
      }
      // 既存のコピー機構を利用してクリップボードへ（cut=false）
      try{
        copySelectionToClipboard(false);
      }catch(e){
        console.error('duplicate: copySelectionToClipboard failed:', e);
        return;
      }
      // 貼り付け位置は「選択外接矩形の左上 + (32,32)」
      try{
        const bounds = computeBounds(targets);
        const dropPoint = { x: bounds.minX + 32, y: bounds.minY + 32 };
        pasteClipboardAt(dropPoint);
        // pasteClipboardAt 内で render / autosave / pushHistory が呼ばれる
      }catch(e){
        console.error('duplicate: pasteClipboardAt failed:', e);
      }
    }

    function rotateObject(obj, deg){
      obj.rotate((obj.angle || 0) + deg);
      obj.setCoords();
      canvas.renderAll();
    }

    /**
     * 菱形（ダイヤ）を追加する。
     * - 基本は正方形を45度回転
     * - 四角と同じく、ダブルクリック/Enterでテキスト編集、Spaceで色変更可能（既存処理が適用）
     */
    function addDiamond(){
      const size = 140;
      const diamond = new fabric.Rect({
        left:0, top:0, width:size, height:size,
        rx:8, ry:8,
        fill:'#f59e0b', stroke:'#f59e0b', strokeWidth:3,
        strokeUniform:true, angle:45
      });
      createLabeledGroup([diamond]);
    }

    /**
     * キャンバスの拡大・縮小をリセットする。
     */ 
    function zoomResetCanvas() {
      //倍率を1に設定する
      canvas.setZoom(1);
      //左上を原点に移動する
      canvas.absolutePan( new fabric.Point(0,0) );
    }

    // =========================
    // 削除（複数選択対応）
    // =========================
    function removeSelected(){
      const selected = canvas.getActiveObjects();
      if (!selected || !selected.length) return;
      selected.forEach(o => canvas.remove(o));
      canvas.discardActiveObject();
      const render = canvas.requestRenderAll || canvas.renderAll;
      render.call(canvas);
      scheduleAutosave();
      pushHistory();
    }

    // =========================
    // イベント
    // =========================
    canvas.on('mouse:move', (evt) => {
      const p = canvas.getPointer(evt.e);
      lastPointer = { x: p.x, y: p.y };
      // updateLinePreviewIfNeeded();
      // updatePlainLinePreviewIfNeeded();
      updateStrokePreview();
    });
    canvas.upperCanvasEl.addEventListener('dblclick', (domEvt) => {
      const target = canvas.findTarget(domEvt, true);
      if (!target) return;
      editLabelByDblClick(target);
    });
    canvas.on('mouse:down', (evt) => {
      // ペンモード中は図形確定などのクリック系処理は無効化（描画のみ）
      if (penMode) return;

      // if (finalizeLineDrawingIfNeeded(evt.e)) return;
      if (finalizeStrokeDrawingIfNeeded(evt.e)) return;
      if (!evt.target){ canvas.discardActiveObject(); canvas.renderAll(); }
    });
    canvas.on('mouse:wheel', (opt) => {
      // 再描画時に原点マーカーも更新される（after:renderで描画）
      // ここでは処理のみ。描画は最後の renderAll に任せる。

      const e = opt.e;
      // const delta = e.deltaY || 0;
      const dy = e.deltaY || 0;
      const dx = e.deltaX || 0;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      // 優先順位:
      // 1) Ctrl+Shift … 水平パン
      // 2) ctrlKey … ズーム
      // 3) 無修飾 … deltaX が優勢なら水平パン、そうでなければ垂直パン
      if (e.ctrlKey && e.shiftKey){
        // ホイールの上下を左右移動に割当て（自然方向: 下で右へ）
        panViewport(-dy, 0); // e は画面座標の＋が右なので、-dyで右へ
        e.preventDefault(); e.stopPropagation();
        return;
      }
      if (e.ctrlKey){
        // ズーム（マウス位置を中心に）
        let z = canvas.getZoom();
        z *= Math.pow(ZOOM_WHEEL_FACTOR, dy);
        z = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, z));
        canvas.zoomToPoint({x:e.offsetX, y:e.offsetY}, z);
        e.preventDefault(); e.stopPropagation();
        // ズーム時はメタのみ更新（updatedAtは変更しない）
        try{ saveViewportMeta(currentSlot, { touchUpdatedAt:false }); }catch(_){}
        return;
      }
      // 無修飾:
      // - トラックパッドの横スクロール（deltaX）が優勢なら水平パン
      // - それ以外は垂直パン（自然方向: 下で下へ）
      if (absX > absY){
        // 水平パン（右スクロール=正のdeltaX → 右へ移動）
        panViewport(-dx, 0);
      }else{
        // 垂直パン（下スクロール=正のdeltaY → 下へ移動）
        panViewport(0, -dy); // f は＋で下へ移動するため -dy
      }
      e.preventDefault(); e.stopPropagation();
    });

    function handleKeydown(ev){
      const tag = (document.activeElement && document.activeElement.tagName) || '';
      if (tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT') return;
      if (ev.isComposing || ev.repeat) return;

      const keyLower = (ev.key || '').toLowerCase();
      const code = ev.code || '';
      const active = canvas.getActiveObject();
      const isCtrl = ev.ctrlKey || ev.metaKey;

      // Ctrl+Shift+V … クリップボード画像を貼り付け
      // （ペンモード中は上の return で抜けるため無効）
      if (isCtrl && ev.shiftKey && (keyLower === 'v' || code === 'KeyV')){
        ev.preventDefault();
        try{
          pasteImageFromClipboardAt(getDropPoint());
        }catch(e){ console.warn(e); }
        return;
      }

      // ペンモード時の Esc: 解除して終了
      if ((ev.key === 'Escape' || ev.code === 'Escape') && penMode){
        ev.preventDefault();
        exitPenMode();
        return;
      }
      // ペンモード中は以降のショートカットを原則無効化
      if (penMode) return;

      // --- Copy / Cut / Paste ---
      if (isCtrl && keyLower === 'c'){
        ev.preventDefault();
        copySelectionToClipboard(false);
        return;
      }
      if (isCtrl && keyLower === 'x'){
        ev.preventDefault();
        copySelectionToClipboard(true);
        return;
      }
      if (isCtrl && keyLower === 'v'){
        ev.preventDefault();
        pasteClipboardAt(getDropPoint());
        return;
      }

      // Undo/Redo
      if (isCtrl && keyLower === 'z' && ev.shiftKey){ ev.preventDefault(); redo(); return; }
      if (isCtrl && keyLower === 'z'){ ev.preventDefault(); undo(); return; }

      // Select All
      if (isCtrl && (keyLower === 'a' || code === 'KeyA')){
        ev.preventDefault();
        const objs = canvas.getObjects();
        if (objs.length){
          const sel = new fabric.ActiveSelection(objs, { canvas });
          canvas.setActiveObject(sel);
          const render = canvas.requestRenderAll || canvas.renderAll;
          render.call(canvas);
        }
        return;
      }

      // 回転/スケール
      if (isCtrl && keyLower==='r'){ ev.preventDefault(); if (active) { rotateObject(active, ev.shiftKey ? -15 : 15); scheduleAutosave(); pushHistoryDebounced(); } return; }
      if (keyLower==='+'){ ev.preventDefault(); if (active){ active.set({ scaleX:(active.scaleX||1)*(ev.shiftKey?1.25:1.1), scaleY:(active.scaleY||1)*(ev.shiftKey?1.25:1.1) }); active.setCoords(); canvas.renderAll(); scheduleAutosave(); pushHistoryDebounced(); } return; }
      if (keyLower==='-'){ ev.preventDefault(); if (active){ active.set({ scaleX:(active.scaleX||1)*(ev.shiftKey?0.8:0.9),  scaleY:(active.scaleY||1)*(ev.shiftKey?0.8:0.9)  }); active.setCoords(); canvas.renderAll(); scheduleAutosave(); pushHistoryDebounced(); } return; }

      // 追加
      if (keyLower==='c' || code==='KeyC'){ ev.preventDefault(); addCircle(); scheduleAutosave(); pushHistory(); return; }
      if (keyLower==='s' || code==='KeyS'){ ev.preventDefault(); addRect();   scheduleAutosave(); pushHistory(); return; }
      if (keyLower==='r' || code==='KeyR'){ ev.preventDefault(); addDiamond(); scheduleAutosave(); pushHistory(); return; }
      if (keyLower==='t' || code==='KeyT'){ ev.preventDefault(); addTextBox(); scheduleAutosave(); pushHistory(); return; }

      // 線
      // 既存: A … 実線（従来動作は実線に統一）
      if ((keyLower==='a' || code==='KeyA') && !ev.shiftKey){
        ev.preventDefault(); startStrokeDrawing({ mode:'arrow', dashed:false }); return;
      }
      // 変更: Shift + A … 矢印なしの“実線”
      if ((keyLower==='a' || code==='KeyA') && ev.shiftKey){
        ev.preventDefault(); startStrokeDrawing({ mode:'line', dashed:false }); return;
      }
      // 変更: Q … 矢印なしの“点線”
      if (keyLower==='q' || code==='KeyQ'){
        ev.preventDefault(); startStrokeDrawing({ mode:'line', dashed:true }); return;
      }

      // （Esc のズーム/リセットは、ペンモード時は上の分岐で消化）
      // Esc: 矢印描画キャンセル
      if (strokeDraw.mode && (keyLower==='escape' || code==='Escape')){ ev.preventDefault(); cancelStrokePreview(true); return; }

      // Esc: 拡大縮小・ポイントリセット
      if (keyLower === 'escape'){ ev.preventDefault(); zoomResetCanvas(); saveViewportMeta(currentSlot, { touchUpdatedAt: false }); return; }

      // 移動
      if (active){
        const step = ev.shiftKey ? 10 : 1;
        if (keyLower==='arrowup'){ ev.preventDefault(); nudgeObject(active,0,-step); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowdown'){ ev.preventDefault(); nudgeObject(active,0, step); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowleft'){ ev.preventDefault(); nudgeObject(active,-step,0); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowright'){ ev.preventDefault(); nudgeObject(active, step,0); scheduleAutosave(); pushHistoryDebounced(); return; }
      }

      // ---- Zオーダー トグル（f）----
      // 押すたびに「最前面」↔「最背面」をトグルする
      // 複数選択時は全てに適用
      if (keyLower === 'f' || code === 'KeyF'){
        ev.preventDefault();
        const targets = canvas.getActiveObjects();
        if (targets && targets.length){
          const bringFn = canvas.bringObjectToFront?.bind(canvas);
          const sendFn  = canvas.sendObjectToBack?.bind(canvas);

          if (toggleBringToFrontFlag){
            // 最前面へ：選択順のまま積み上げ
            if (typeof bringFn === 'function'){
              targets.forEach(o => bringFn(o));
            }
          } else {
            // 最背面へ：背面に送る（逆順適用で相対順を維持）
            if (typeof sendFn === 'function'){
              [...targets].reverse().forEach(o => sendFn(o));
            }
          }
          toggleBringToFrontFlag = !toggleBringToFrontFlag;
          (canvas.requestRenderAll || canvas.renderAll).call(canvas);
          scheduleAutosave();
          pushHistoryDebounced();
        }
        return;
      }

      // 複製（Ctrl+D）
      if (isCtrl && keyLower==='d'){ ev.preventDefault(); duplicateObject(active); scheduleAutosave(); return; }

      // Delete/Backspace / d で削除
      if (keyLower==='delete' || keyLower==='backspace'){ ev.preventDefault(); removeSelected(); return; }
      if (keyLower==='d'){ ev.preventDefault(); removeSelected(); return; }

      // Enter: テキスト編集
      if (keyLower==='enter' || code==='Enter'){ ev.preventDefault(); if (active) editLabelByDblClick(active); scheduleAutosave(); pushHistoryDebounced(); return; }

      // Space: 色
      if (keyLower===' ' || keyLower==='spacebar' || code==='Space'){ ev.preventDefault(); if (active) cycleFillColor(active); scheduleAutosave(); pushHistoryDebounced(); return; }
    }
    window.addEventListener('keydown', handleKeydown, true);

    // Zオーダーのトグル状態（true: 次は最前面 / false: 次は最背面）
    // セッション全体で共有（直近の操作からトグル）
    let toggleBringToFrontFlag = true;

    // クリックでフォーカス
    document.addEventListener('pointerdown', () => { canvasEl.focus({preventScroll:true}); });

    // PNG出力
    pngBtn.addEventListener('click', () => {
      const dataURL = canvas.toDataURL({ format:'png', multiplier:2, enableRetinaScaling:false });
      const a = document.createElement('a');
      a.href = dataURL;
      const title = getSafeTitleForFilename(currentSlot);
      const stamp = formatNowForFilename();
      a.download = `${title}_${stamp}.png`;
      document.body.appendChild(a); a.click(); a.remove();
    });

    // 画像挿入
    imageBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'image/*';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = String(reader.result || ''); if (!dataURL) return;
          fabric.Image.fromURL(dataURL, (img) => {
            const drop = getDropPoint();
            const maxW = canvas.getWidth()*0.6, maxH = canvas.getHeight()*0.6;
            const scale = Math.min(1, maxW/img.width, maxH/img.height);
            img.set({ originX:'center', originY:'center', left:drop.x, top:drop.y, scaleX:scale, scaleY:scale, objectCaching:false });
            canvas.add(img);
            canvas.setActiveObject(img);
            const render = canvas.requestRenderAll || canvas.renderAll;
            render.call(canvas);
            scheduleAutosave(); pushHistory();
          }, { crossOrigin: null });
        };
        reader.readAsDataURL(file);
      };
      input.click();
    });

    // クリア
    clearBtn.addEventListener('click', () => {
      const ok = window.confirm(`スロット ${currentSlot + 1} の全オブジェクトを削除します。\nこの操作は元に戻せません。よろしいですか？`);
      if (!ok) return;
      canvas.clear();
      setCanvasBg('#ffffff');
      // クリア後に原点マーカーを復元
      ensureOriginMarker(); keepOriginMarkerBack();
      // タイトルもクリア（要件：クリアボタンでタイトルも空に）
      try{
        clearSlotTitle(currentSlot);
      }catch(_){}
      // 視点リセット＆保存
      // クリア直後の視点（ズーム1・原点）を保存しておく（updatedAt は編集として更新）
      canvas.setViewportTransform([1,0,0,1,0,0]);
      saveToSlot(currentSlot);
      resetHistoryBaseline();
    });

    // JSON入出力
    importBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'application/json';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try{
            canvas.clear(); setCanvasBg('#ffffff');
            applyingHistory = true;
            importCanvasJSON(String(reader.result), () => {
              applyingHistory = false;
              // インポート後に原点マーカーを復元
              ensureOriginMarker(); keepOriginMarkerBack();
              // インポート直後は今の視点（ズーム1/原点）。保存時に meta も併せて保存。
              saveToSlot(currentSlot);
              resetHistoryBaseline();
              refreshSlotButtonsUI();
            });
          }catch(e){ console.error('import failed:', e); applyingHistory=false; }
        };
        reader.readAsText(file);
      };
      input.click();
    });
    exportBtn.addEventListener('click', () => {
      // エクスポートは fabric JSON（外部交換しやすい）
      const json = exportCanvasJSON();
      const blob = new Blob([json], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const title = getSafeTitleForFilename(currentSlot);
      const stamp = formatNowForFilename();
      a.download = `${title}_${stamp}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    });

    // =========================
    // 初期化
    // =========================
    ensureOriginMarker();
    buildSlotButtons();
    resizeCanvasToViewport();
    currentSlot = 0;
    refreshSlotButtonsUI();
    loadFromSlot(currentSlot);
    canvasEl.focus({preventScroll:true});
    resetHistoryBaseline();
    keepOriginMarkerBack();
    // ペンUI初期状態
    setPenUIActive(null);

  })();



// TEST for out connection
// (function(){
//   // 小さなテストパネルを作成
//   const panel = document.createElement('div');
//   panel.style.cssText = 'position:fixed;right:12px;bottom:12px;z-index:99999;background:#fff;border:1px solid #cbd5e1;border-radius:8px;box-shadow:0 6px 20px rgba(2,6,23,.15);padding:10px;font:12px system-ui;';
//   panel.innerHTML = `
//     <div style="font-weight:700;margin-bottom:6px;">Network Guard テスト</div>
//     <div style="display:grid;gap:6px;">
//       <button data-t="fetch">fetch</button>
//       <button data-t="xhr">XMLHttpRequest</button>
//       <button data-t="ws">WebSocket</button>
//       <button data-t="sse">EventSource</button>
//       <button data-t="beacon">sendBeacon</button>
//       <button data-t="img">Image.src</button>
//       <hr/>
//       <button data-t="all" style="font-weight:700;">全部テスト</button>
//       <button data-t="ok" title="許可される(同一オリジン/データURL)制御テスト">制御テスト(許可想定)</button>
//       <button data-t="close">パネル閉じる</button>
//     </div>
//   `;
//   panel.querySelectorAll('button').forEach(b=>{
//     b.style.cssText = 'padding:6px 8px;border:1px solid #cbd5e1;border-radius:6px;background:#f8fafc;cursor:pointer';
//     b.onmouseenter=()=>b.style.background='#eef2ff';
//     b.onmouseleave=()=>b.style.background='#f8fafc';
//   });
//   document.body.appendChild(panel);

//   const externalURL = 'https://example.com/';
//   const externalImg = 'https://example.com/favicon.ico';
//   const externalSSE = 'https://example.com/sse'; // 実SSEでなくてもブロック検知されればOK
//   const externalWS  = 'wss://echo.websocket.events'; // 汎用のWSエコー。ガードがあれば接続前にブロックされる

//   async function testFetch(){
//     console.log('[TEST] fetch ->', externalURL);
//     try{
//       const res = await fetch(externalURL, {mode:'cors'});
//       console.log('fetch result (unexpected if blocked):', res);
//     }catch(e){
//       console.warn('fetch blocked as expected:', e.message || e);
//     }
//   }

//   function testXHR(){
//     console.log('[TEST] XHR ->', externalURL);
//     try{
//       const xhr = new XMLHttpRequest();
//       xhr.open('GET', externalURL, true);
//       xhr.onload = ()=>console.log('XHR onload (unexpected if blocked)', xhr.status);
//       xhr.onerror= ()=>console.warn('XHR error (expected when blocked)');
//       xhr.send();
//     }catch(e){
//       console.warn('XHR blocked as expected:', e.message || e);
//     }
//   }

//   function testWS(){
//     console.log('[TEST] WebSocket ->', externalWS);
//     try{
//       const ws = new WebSocket(externalWS);
//       ws.onopen  = ()=>console.log('WS open (unexpected if blocked)');
//       ws.onerror = (ev)=>console.warn('WS error (expected when blocked)', ev);
//       ws.onclose = ()=>console.warn('WS close');
//     }catch(e){
//       console.warn('WS blocked as expected:', e.message || e);
//     }
//   }

//   function testSSE(){
//     console.log('[TEST] EventSource ->', externalSSE);
//     try{
//       const es = new EventSource(externalSSE);
//       es.onopen  = ()=>console.log('SSE open (unexpected if blocked)');
//       es.onerror = (ev)=>console.warn('SSE error (expected when blocked)', ev);
//     }catch(e){
//       console.warn('SSE blocked as expected:', e.message || e);
//     }
//   }

//   function testBeacon(){
//     console.log('[TEST] sendBeacon ->', externalURL+'beacon');
//     try{
//       const ok = navigator.sendBeacon(externalURL+'beacon', 'hello');
//       console.log('sendBeacon returned (false expected when blocked):', ok);
//     }catch(e){
//       console.warn('sendBeacon blocked as expected:', e.message || e);
//     }
//   }

//   function testImage(){
//     console.log('[TEST] Image.src ->', externalImg);
//     const img = new Image();
//     img.onload = ()=>console.log('Image loaded (unexpected if blocked)');
//     img.onerror = ()=>console.warn('Image blocked/error as expected');
//     img.src = externalImg;
//   }

//   // 許可される制御テスト（同一オリジン/データURL）
//   async function testAllowedControl(){
//     console.log('[CONTROL] dataURL image (should be allowed)');
//     const img = new Image();
//     img.onload = ()=>console.log('dataURL image loaded OK');
//     img.onerror = ()=>console.warn('dataURL image error (unexpected)');
//     img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAACENnwnAAAAD0lEQVR4nGMAAQAABgABi0m8GQAAAABJRU5ErkJggg==';

//     console.log('[CONTROL] same-origin fetch (should be allowed)');
//     try{
//       const res = await fetch(location.pathname, {cache:'no-store'});
//       console.log('same-origin fetch OK (status):', res.status);
//     }catch(e){
//       console.warn('same-origin fetch blocked (unexpected):', e);
//     }
//   }

//   async function runAll(){
//     await testFetch();
//     testXHR();
//     testWS();
//     testSSE();
//     testBeacon();
//     testImage();
//   }

//   panel.addEventListener('click', (e)=>{
//     const t = e.target && e.target.getAttribute('data-t');
//     if (!t) return;
//     if (t==='fetch') testFetch();
//     if (t==='xhr') testXHR();
//     if (t==='ws') testWS();
//     if (t==='sse') testSSE();
//     if (t==='beacon') testBeacon();
//     if (t==='img') testImage();
//     if (t==='all') runAll();
//     if (t==='ok') testAllowedControl();
//     if (t==='close') panel.remove();
//   });

//   console.log('%c[Network Guard Tester] パネルを右下に表示しました。', 'color:#0ea5e9;font-weight:bold');
// })();



</script>
</body>
</html>
