<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Fabric.js 図形作成ツール（Undo/Redo・スロット改良・複数削除）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --fg:#0f172a;
      --line:#3a3c44;
      --slotBg:#f5f7fb;
      --slotSel:#0ea5e9;
      --slotTxt:#0b1323;
      --slotEmptyBg:#f1f5f9;
      --slotEmptyTxt:#94a3b8;
      /* データあり（淡いオレンジ） */
      --slotHasBg:#fff1e6; /* very light orange */
      --slotHasBorder:#f59e0b;
      --slotHasTxt:#9a3412;
    }
    html,body{height:100%;margin:0;color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"ヒラギノ角ゴ ProN",Meiryo,sans-serif;}
    header{padding:10px 14px;border-bottom:1px solid var(--line);display:flex;gap:18px;align-items:center;flex-wrap:wrap;}
    .kbd{padding:.2em .45em;border:1px solid var(--line);border-bottom-width:2px;border-radius:6px;font-weight:600;background:#f2f3f5;}
    #wrap{height:calc(100% - 104px);}
    #stage{display:block;outline:none;background:#fff;}
    .upper-canvas{background: transparent !important;}

    /* スロットツールバー */
    #toolbar{display:flex;align-items:center;gap:10px;padding:8px 14px;border-bottom:1px solid var(--line);background:#fafbff;flex-wrap:wrap;}
    .slot-btn{
      min-width:38px;padding:6px 10px;border:1px solid #cfd6e3;border-radius:8px;
      background:var(--slotBg);color:var(--slotTxt);font-weight:600;cursor:pointer;user-select:none;position:relative;
      transition:background .15s ease,border-color .15s ease,color .15s ease;
    }
    .slot-btn.active{
      border-color:var(--slotSel);box-shadow:0 0 0 4px rgba(233, 14, 14, 0.685) inset;color:var(--slotSel);background:#e8f6fd;
    }
    .slot-btn.empty{
      background:var(--slotEmptyBg);color:var(--slotEmptyTxt);border-style:dashed;
    }
    .slot-btn.hasdata{
      background:var(--slotHasBg);border-color:var(--slotHasBorder);color:var(--slotHasTxt);
    }
    .toolbar-button{padding:6px 12px;border:1px solid #cfd6e3;border-radius:8px;background:#ffffff;font-weight:600;cursor:pointer;}
    .toolbar-button:hover{background:#f6f8fc;}
    .spacer{flex:1 1 auto;}

    /* スロットサムネプレビュー */
    #slotPreview{
      position:fixed;left:0;top:0;transform: translate(12px, 12px);
      display:none;z-index:9999;background:#fff;border:1px solid rgba(0,0,0,.12);
      box-shadow:0 10px 24px rgba(2,6,23,.15);border-radius:10px;padding:6px;pointer-events:none;
    }
    #slotPreview img{display:block;max-width:280px;max-height:180px;}
    #slotPreview .caption{font-size:12px;color:#475569;margin-top:4px;text-align:center;}
  </style>
</head>
<body>
  <header id="header">
    <div>
      <span class="kbd">c</span> 円 /
      <span class="kbd">s</span> 四角 /
      <span class="kbd">t</span> テキスト /
      <span class="kbd">a</span> 線
    </div>
    <div>
      <span class="kbd">Ctrl|⌘ + Z</span> Undo /
      <span class="kbd">Ctrl|⌘ + Shift + Z</span> Redo /
      <span class="kbd">Ctrl|⌘ + A</span> すべて選択 /
      <span class="kbd">d</span> 選択削除
    </div>
  </header>

  <div id="toolbar" aria-label="保存スロットとエクスポート">
    <div id="slotButtons"></div>
    <div class="spacer"></div>
    <button id="imageBtn" class="toolbar-button" type="button">画像挿入</button>
    <button id="pngBtn" class="toolbar-button" type="button">PNG出力</button>
    <button id="importBtn" class="toolbar-button" type="button">JSONインポート</button>
    <button id="exportBtn" class="toolbar-button" type="button">JSONエクスポート</button>
    <button id="clearBtn" class="toolbar-button" type="button">クリア</button>
  </div>

  <div id="wrap">
    <canvas id="stage" tabindex="0" aria-label="図形キャンバス"></canvas>
  </div>

  <div id="slotPreview" aria-hidden="true">
    <img alt="slot preview" />
    <div class="caption"></div>
  </div>

  <!-- Fabric.js v6.7.1 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/671/index.min.js"></script>
  <script>
  (function(){
    // Debug
    const DEBUG = true;
    const D = (...a) => DEBUG && console.log('[thumb]', ...a);

    const canvasEl = document.getElementById('stage');
    const headerEl = document.getElementById('header');
    const toolbarEl = document.getElementById('toolbar');
    const slotButtonsEl = document.getElementById('slotButtons');
    const exportBtn = document.getElementById('exportBtn');
    const imageBtn  = document.getElementById('imageBtn');
    const importBtn = document.getElementById('importBtn');
    const clearBtn  = document.getElementById('clearBtn');
    const pngBtn    = document.getElementById('pngBtn');

    const slotPreviewEl = document.getElementById('slotPreview');
    const slotPreviewImg = slotPreviewEl.querySelector('img');
    const slotPreviewCaption = slotPreviewEl.querySelector('.caption');

    const canvas = new fabric.Canvas(canvasEl, {
      backgroundColor: '#ffffff',
      selection: true,
      preserveObjectStacking: true
    });

    fabric.Object.prototype.transparentCorners = false;
    fabric.Object.prototype.cornerColor = '#0ea5e9';
    fabric.Object.prototype.cornerStyle = 'rect';
    fabric.Object.prototype.cornerSize = 10;
    fabric.Object.prototype.borderColor = '#0ea5e9';

    // カラーパレット
    const color_palette = ['#60a5fa','#22c55e','#f59e0b','#ef4444','#a78bfa', "#ffffff", "#000000"];

    // 図形作成時の既定パラメータ
    const line_param = { stroke:'#111827', strokeWidth:3, strokeLineCap:'round' };
    const arrow_param = { width:32, height:32, fill:'#111827', stroke:'#111827', strokeWidth:2, originX:'center', originY:'center' };

    function resizeCanvasToViewport(){
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const hh = Math.ceil(headerEl.getBoundingClientRect().height);
      const th = Math.ceil(toolbarEl.getBoundingClientRect().height);
      canvas.setWidth(vw);
      canvas.setHeight(Math.max(0, vh - hh - th));
      canvas.calcOffset();
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
    }
    window.addEventListener('resize', resizeCanvasToViewport, { passive:true });

    let lastPointer = null;
    function getDropPoint(){
      if (lastPointer) return lastPointer;
      return { x: canvas.getWidth()/2, y: canvas.getHeight()/2 };
    }

    // ===== スロット機能 =====
    const SLOT_COUNT = 10;
    const LS_KEY_PREFIX = 'wb_slot_v1_';
    const LS_KEY_META_PREFIX = 'wb_slot_v1_meta_';  // スロット毎の視点メタデータ保存用（ズーム/右上ワールド座標）
    let currentSlot = 0;
    let autosaveTimer = null;

    function exportCanvasJSON(){
      const json = canvas.toJSON();
      return JSON.stringify(json, null, 2);
    }
    function importCanvasJSON(jsonText, cb){
      try{
        const parsed = JSON.parse(jsonText);
        canvas.loadFromJSON(parsed, () => {
          attachGroupLabelPointers();
          canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
          canvasEl.focus({preventScroll:true});
          cb && cb();
        });
      }catch(err){ console.error('loadFromJSON failed:', err); }
    }
    function attachGroupLabelPointers(){
      for (const obj of canvas.getObjects()){
        if (obj.type === 'group' && obj._objects){
          const label = obj._objects.find(o => o.type === 'text');
          if (label) obj._label = label;
          if (obj._label) centerGroupLabel(obj);
        }
      }
    }
    function saveToSlot(slot){
      try{
        const key = LS_KEY_PREFIX + slot;
        localStorage.setItem(key, exportCanvasJSON());
        saveViewportMeta(slot); // 視点メタも一緒に保存
        refreshSlotButtonsUI();
      }catch(err){ console.error('saveToSlot failed:', err); }
    }
    function loadFromSlot(slot){
      const key = LS_KEY_PREFIX + slot;
      const json = localStorage.getItem(key);
      if (!json){
        canvas.clear();
        setCanvasBg('#ffffff');
        return;
      }
      // importCanvasJSON(json);
      importCanvasJSON(json, () => {
        applyViewportFromMeta(slot);  // 視点メタを復元（あれば）
      });
    }
    function setCanvasBg(color){
      canvas.backgroundColor = color;
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
    }

    function slotHasData(i){
      const storage_data = localStorage.getItem(LS_KEY_PREFIX + i);
      if (!!storage_data) {
        const parsed = JSON.parse(storage_data);
        return (parsed.objects.length !== 0);
      }
      return false;
    }

    // ===== ビューポート保存/復元ユーティリティ =====
    // 画面上の (screenX, screenY) に対応するワールド座標を取得
    function getWorldPointAtScreen(screenX, screenY){
      const vt = canvas.viewportTransform || [1,0,0,1,0,0];
      const inv = fabric.util.invertTransform(vt);
      const p = fabric.util.transformPoint(new fabric.Point(screenX, screenY), inv);
      return { x: p.x, y: p.y };
    }
    // 現在のズームと「画面右上に来ているワールド座標」を保存
    // options.touchUpdatedAt === false の時は updatedAt を変更しない
    function saveViewportMeta(slot, { touchUpdatedAt = true } = {}){
      try{
        const zoom = canvas.getZoom();
        const viewTR = getWorldPointAtScreen(canvas.getWidth(), 0); // 右上は (canvas.width, 0) のスクリーン座標
        // 既存の updatedAt を引き継ぐ（touchUpdatedAt=false の場合）
        let prevUpdated = null;
        try {
          const prevRaw = localStorage.getItem(LS_KEY_META_PREFIX + slot);
          if (prevRaw) prevUpdated = (JSON.parse(prevRaw).updatedAt || null);
        } catch(_){}
        const updatedAt = touchUpdatedAt ? new Date().toISOString() : prevUpdated;
        const meta = { zoom, viewTR, updatedAt };
        localStorage.setItem(LS_KEY_META_PREFIX + slot, JSON.stringify(meta));
      }catch(e){ console.warn('saveViewportMeta failed:', e); }
    }
    // 保存済みの視点メタを取得
    function readViewportMeta(slot){
      try{
        const raw = localStorage.getItem(LS_KEY_META_PREFIX + slot);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed.zoom !== 'number' || !parsed.viewTR) return null;
        return parsed;
      }catch(e){ return null; }
    }
    // メタに基づき viewportTransform を再設定
    function applyViewportFromMeta(slot){
      const meta = readViewportMeta(slot);
      if (!meta) return;
      const z = meta.zoom;
      if (!z || z <= 0) return;
      const vx = meta.viewTR?.x ?? 0;
      const vy = meta.viewTR?.y ?? 0;
      // 右上 (screenW, 0) が (vx, vy) に一致するように並進を求める:
      // [ z 0 0 z e f ] * [vx, vy, 1]^T のスクリーンX = screenW, Y = 0
      // => e = screenW - z*vx, f = 0 - z*vy
      const e = canvas.getWidth() - z * vx;
      const f = 0 - z * vy;
      canvas.setViewportTransform([ z, 0, 0, z, e, f ]);
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
    }

    function refreshSlotButtonsUI(){
      const btns = slotButtonsEl.querySelectorAll('.slot-btn');
      btns.forEach((btn, idx) => {
        const has = slotHasData(idx);
        btn.classList.toggle('active', idx === currentSlot);
        btn.classList.toggle('empty', !has);
        btn.classList.toggle('hasdata', has);
      });
    }

    function selectSlot(i){
      currentSlot = Math.max(0, Math.min(SLOT_COUNT-1, i));
      refreshSlotButtonsUI();
      applyingHistory = true;
      loadFromSlot(currentSlot);
      applyingHistory = false;
      resetHistoryBaseline();
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      canvasEl.focus({preventScroll:true});
    }

    function buildSlotButtons(){
      slotButtonsEl.innerHTML = '';
      for (let i=0; i<SLOT_COUNT; i++){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'slot-btn';
        btn.textContent = String(i+1);
        btn.title = `スロット ${i+1}`;
        btn.dataset.slot = String(i);

        btn.addEventListener('click', () => selectSlot(i));

        // Shift+ホバーでプレビュー
        // btn.addEventListener('pointerenter', (e) => { hoveredSlot = i; lastHoverEvent = e; reevaluateSlotPreview(); });
        // btn.addEventListener('pointermove',  (e) => { hoveredSlot = i; lastHoverEvent = e; reevaluateSlotPreview(); positionSlotPreview(e); });
        // btn.addEventListener('pointerleave', () => { hoveredSlot = null; hideSlotPreview(); });
        btn.addEventListener('pointerenter', (e) => {
          hoveredSlot = i;
          lastHoverEvent = e;
          if (e.shiftKey) showSlotPreview(i, e);
          else hideSlotPreview();
        });
        btn.addEventListener('pointermove', (e) => {
          hoveredSlot = i;
          lastHoverEvent = e;
          if (e.shiftKey) showSlotPreview(i, e);
          else hideSlotPreview();
        });
        btn.addEventListener('pointerleave', () => {
          hoveredSlot = null;
          hideSlotPreview();
        });

        slotButtonsEl.appendChild(btn);
      }
      refreshSlotButtonsUI();
    }

    function scheduleAutosave(){
      clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(() => saveToSlot(currentSlot), 300);
    }

    // 変更イベント→自動保存 & 履歴
    // ['object:added','object:removed','object:modified','object:scaled','object:rotated','object:moved'].forEach(evt=>{
    ['object:modified','object:scaled','object:rotated','object:moved'].forEach(evt=>{
      canvas.on(evt, () => { scheduleAutosave(); pushHistoryDebounced(); });
    });

    // ===== Undo/Redo =====
    const HISTORY_LIMIT = 50;
    const historyStack = [];
    const redoStack = [];
    let applyingHistory = false;
    let historyTimer = null;

    function getCanvasSnapshot(){ return exportCanvasJSON(); }
    function applySnapshot(json){
      applyingHistory = true;
      canvas.clear();
      setCanvasBg('#ffffff');
      importCanvasJSON(json, () => {
        applyingHistory = false;
        canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      });
    }
    function pushHistory(){
      if (applyingHistory) return;
      const snap = getCanvasSnapshot();
      if (historyStack.length && historyStack[historyStack.length-1] === snap) return;
      historyStack.push(snap);
      if (historyStack.length > HISTORY_LIMIT) historyStack.shift();
      redoStack.length = 0;
    }
    function pushHistoryDebounced(){
      if (applyingHistory) return;
      clearTimeout(historyTimer);
      historyTimer = setTimeout(() => pushHistory(), 200);
    }
    function resetHistoryBaseline(){
      historyStack.length = 0; redoStack.length = 0; pushHistory();
    }
    function undo(){
      if (historyStack.length <= 1) return;
      const cur = historyStack.pop();
      const prev = historyStack[historyStack.length-1];
      redoStack.push(cur);
      applySnapshot(prev);
    }
    function redo(){
      if (!redoStack.length) return;
      const next = redoStack.pop();
      historyStack.push(next);
      applySnapshot(next);
    }

    // ===== サムネプレビュー =====
    const slotThumbCache = new Map(); // cacheKey(slotIndex|updatedAt) -> dataURL
    let hoveredSlot = null;
    let lastHoverEvent = null;
    let shiftHeld = false;

    // function hideSlotPreview(){ slotPreviewEl.style.display = 'none'; }
    // スロットボタン上に表示するプレビューを消去
    function hideSlotPreview(){
      slotPreviewEl.style.display = 'none';
      // 古いサムネが残るのを防止
      slotPreviewImg.removeAttribute('src');
    }

    function positionSlotPreview(e){
      if (!e) return;
      slotPreviewEl.style.left = e.clientX + 'px';
      slotPreviewEl.style.top  = e.clientY + 'px';
    }

    function reevaluateSlotPreview(){
      if (hoveredSlot === null || !shiftHeld){ hideSlotPreview(); return; }
      if (!slotHasData(hoveredSlot)){ hideSlotPreview(); return; }

      const e = lastHoverEvent;
      if (e) positionSlotPreview(e);
      // 以降の表示は showSlotPreview に委譲（更新日入り）
      showSlotPreview(hoveredSlot, e);
    }

    // Shiftの押下状態でプレビュー再評価（「あと押し」に対応）
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Shift'){ shiftHeld = true; reevaluateSlotPreview(); }
    }, true);
    window.addEventListener('keyup', (e) => {
      if (e.key === 'Shift'){ shiftHeld = false; hideSlotPreview(); }
    }, true);

    // スロットボタン上のプレビューを表示
    function showSlotPreview(slotIndex, e){
      if (!slotHasData(slotIndex)) { hideSlotPreview(); return; }

      // ここで枠を先に出す（画像は未セットのまま）
      positionSlotPreview(e);
      slotPreviewCaption.textContent = `スロット ${slotIndex+1}`;
      slotPreviewImg.removeAttribute('src'); // 古い残像を消す
      slotPreviewEl.style.display = 'block';

      // const cached = slotThumbCache.get(slotIndex);
      // 保存データとメタ（更新日時）を取得
      const json = localStorage.getItem(LS_KEY_PREFIX + slotIndex);
      const metaRaw = localStorage.getItem(LS_KEY_META_PREFIX + slotIndex);
      let updatedAt = null;
      try { updatedAt = metaRaw ? (JSON.parse(metaRaw).updatedAt || null) : null; } catch(_){}
      const cacheKey = `${slotIndex}|${updatedAt || 'none'}`;

      const cached = slotThumbCache.get(cacheKey);

      if (cached){
        slotPreviewImg.src = cached;
        return; // 既に枠は表示済み
      }
      // const json = localStorage.getItem(LS_KEY_PREFIX + slotIndex);
      if (!json){ hideSlotPreview(); return; }

      // ベースのサムネを生成後、更新日バッジを重ね描き
      // generateThumbnailFromJSON(json, 280, 180).then((dataURL) => {
      //   slotThumbCache.set(slotIndex, dataURL);
      generateThumbnailWithUpdatedAt(json, updatedAt, 280, 180).then((dataURL) => {
        slotThumbCache.set(cacheKey, dataURL);
        // すでに枠は出ているので src を付け替えるだけ
        slotPreviewImg.src = dataURL;
      }).catch(() => {
        hideSlotPreview();
      });
    }

    // 既存の generateThumbnailFromJSON を利用し、上に「最終更新」ラベルを描画して返す
    async function generateThumbnailWithUpdatedAt(jsonText, updatedAtISO, w=280, h=180){
      const baseURL = await generateThumbnailFromJSON(jsonText, w, h);
      // 合成用キャンバス
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d');
      await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { ctx.drawImage(img, 0, 0, w, h); resolve(); };
        img.onerror = reject;
        img.src = baseURL;
      });
      drawUpdatedAtBadge(c, updatedAtISO);
      return c.toDataURL('image/png');
    }

    // スロットボタン上にポップアップ表示するサムネイルを生成
    // @note : v6の Promise 返却に対応。旧版（callback）でも自動フォールバックします。
    async function generateThumbnailFromJSON(jsonText, targetW = 280, targetH = 180) {
      return new Promise(async (resolve, reject) => {
        try {
          // 実体の <canvas> を使う（nullを渡さない）
          const offscreen = document.createElement('canvas');
          offscreen.width = targetW;
          offscreen.height = targetH;

          const sc = new fabric.StaticCanvas(offscreen, {
            width: targetW,
            height: targetH,
            backgroundColor: '#ffffff',
            enableRetinaScaling: false,
            renderOnAddRemove: false
          });

          const parsed = (typeof jsonText === 'string') ? JSON.parse(jsonText) : jsonText;
          const objsRaw = Array.isArray(parsed?.objects) ? parsed.objects : [];

          // 背景
          const bg = parsed.backgroundColor || parsed.background || '#ffffff';
          // sc.setBackgroundColor(bg, sc.renderAll.bind(sc));

          if (!objsRaw.length) {
            sc.renderAll();
            return resolve(offscreen.toDataURL('image/png'));
          }

          // 画像対策
          const reviver = (orig, obj) => {
            if (obj && obj.type === 'image' && !obj.crossOrigin) obj.crossOrigin = 'anonymous';
          };

          // v6: Promise 返却 / 旧版: callback の両対応
          let enlivened;
          const maybePromise = fabric.util.enlivenObjects(objsRaw, { reviver });

          if (maybePromise && typeof maybePromise.then === 'function') {
            // v6: Promise
            enlivened = await maybePromise;
          } else {
            // 旧版: callback シグネチャにフォールバック
            return fabric.util.enlivenObjects(
              objsRaw,
              (arr) => {
                try {
                  arr.forEach(o => sc.add(o));
                  sc.renderAll();
                  const url = _fitAndSnapshot(sc, targetW, targetH);
                  resolve(url);
                } catch (e) { reject(e); }
              },
              null,
              reviver
            );
          }

          // 以降 v6
          enlivened.forEach(o => sc.add(o));
          sc.renderAll();

          const url = _fitAndSnapshot(sc, targetW, targetH);
          resolve(url);

        } catch (e) {
          reject(e);
        }
      });

      // 内部: 外接矩形にフィットさせて PNG を返す
      function _fitAndSnapshot(sc, targetW, targetH) {
        const objs = sc.getObjects();
        if (!objs.length) {
          sc.renderAll();
          return sc.getElement().toDataURL('image/png');
        }
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const o of objs) {
          const br = o.getBoundingRect(true, true);
          minX = Math.min(minX, br.left);
          minY = Math.min(minY, br.top);
          maxX = Math.max(maxX, br.left + br.width);
          maxY = Math.max(maxY, br.top  + br.height);
        }
        const pad = 12;
        const contentW = Math.max(1, (maxX - minX));
        const contentH = Math.max(1, (maxY - minY));
        const sx = (targetW - pad * 2) / contentW;
        const sy = (targetH - pad * 2) / contentH;
        const s  = Math.min(sx, sy);
        const tx = (-minX) * s + pad;
        const ty = (-minY) * s + pad;

        sc.setViewportTransform([ s, 0, 0, s, tx, ty ]);
        sc.renderAll();

        // StaticCanvas に渡した実体 canvas から取得
        return sc.getElement().toDataURL('image/png');
      }
    }



    // === 更新日描画ユーティリティ ===
    function drawUpdatedAtBadge(canvasEl, updatedAtISO){
      const ctx = canvasEl.getContext('2d');
      const text = '最終更新: ' + formatDateLabel(updatedAtISO);
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      const padX = 8, padY = 6;
      // 影響が少ないように事前にメジャー
      const metrics = ctx.measureText(text);
      const w = metrics.width + padX*2;
      const h = 18 + padY*2;
      const x = canvasEl.width - w - 8;
      const y = canvasEl.height - h - 8;

      // 背景（角丸・白半透明）
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      roundRect(ctx, x, y, w, h, 8); ctx.fill();
      // 枠線
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 1;
      roundRect(ctx, x, y, w, h, 8); ctx.stroke();
      // 文字
      ctx.fillStyle = '#334155';
      ctx.fillText(text, x + padX, y + padY + 13);
    }
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function formatDateLabel(iso){
      if (!iso) return '(不明)';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return '(不明)';
      const y  = d.getFullYear();
      const m  = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      return `${y}/${m}/${dd} ${hh}:${mm}`;
    }

    // ===== 既存描画（要点） =====
    const groupOptions = { hasControls:true, hoverCursor:'move', originX:'left', originY:'top', opacity:1, objectCaching:false };

    function centerGroupLabel(group){
      if (!group || !group._label) return;
      const br = group.getBoundingRect(true, true);
      const centerCanvas = new fabric.Point(br.left + br.width/2, br.top + br.height/2);
      const m  = group.calcTransformMatrix();
      const im = fabric.util.invertTransform(m);
      const centerLocal = fabric.util.transformPoint(centerCanvas, im);
      group._label.set({ originX:'center', originY:'center', left:centerLocal.x, top:centerLocal.y, textAlign:'center' });
      group.setCoords();
    }

    function createLabeledGroup(baseObjects){
      const dropPoint = getDropPoint();
      const labelText = new fabric.Text('', { fontSize:16, fill:'#0f172a', originX:'center', originY:'center', top:0, left:0, textAlign:'center', objectCaching:false });
      baseObjects.forEach(o => o.set({ objectCaching:false, globalCompositeOperation:'source-over' }));
      const group = new fabric.Group([...baseObjects, labelText], { ...groupOptions, left: dropPoint.x, top: dropPoint.y, globalCompositeOperation:'source-over' });
      group._label = labelText;
      canvas.add(group);
      centerGroupLabel(group);
      canvas.setActiveObject(group);
      if (canvas.bringToFront) canvas.bringToFront(group);
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      return group;
    }
    function addCircle(){
      const circle = new fabric.Circle({ left:0, top:0, radius:60, fill:'#22c55e', stroke:'#052e16', strokeWidth:3, strokeUniform:true });
      createLabeledGroup([circle]);
    }
    function addRect(){
      const rect = new fabric.Rect({ left:0, top:0, width:150, height:100, rx:8, ry:8, fill:'#60a5fa', stroke:'#0a2472', strokeWidth:3, strokeUniform:true });
      createLabeledGroup([rect]);
    }
    function addTextBox(){
      const drop = getDropPoint();
      const nextText = window.prompt('テキストを入力してください：', '');
      if (nextText === null) return;
      const tb = new fabric.Textbox(nextText, { left: drop.x, top: drop.y, fontSize:18, fill:'#0f172a', textAlign:'left', objectCaching:false });
      canvas.add(tb);
      canvas.setActiveObject(tb);
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
    }

    // 線
    let pendingLineStart = null;
    let previewLine = null;
    let previewLineArrowHead = null;

    function startLineDrawing(){
      const start = getDropPoint();
      pendingLineStart = { x: start.x, y: start.y };

      if (previewLine) { canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead) { canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }

      previewLine = new fabric.Line([start.x, start.y, start.x, start.y],{
        stroke: line_param.stroke, strokeWidth: line_param.strokeWidth, strokeLineCap: line_param.strokeLineCap,
        opacity:.6, selectable:false, evented:false, strokeDashArray:[6,6]
      });
      previewLineArrowHead = new fabric.Triangle({
        left:start.x, top:start.y, width:arrow_param.width, height:arrow_param.height, angle:0,
        fill:arrow_param.fill, stroke:arrow_param.stroke, strokeWidth:arrow_param.strokeWidth,
        originX:arrow_param.originX, originY:arrow_param.originY, selectable:false, evented:false
      });

      canvas.add(previewLine, previewLineArrowHead);
      canvas.bringToFront && canvas.bringToFront(previewLine);
      canvas.renderAll();
    }
    function calcurateArrowDegree(x1, y1, x2, y2) {
      return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
    }
    function updateLinePreviewIfNeeded(){
      if (!pendingLineStart || !previewLine) return;
      const pos = getDropPoint();
      previewLine.set({ x2: pos.x, y2: pos.y });
      if (previewLineArrowHead){
        previewLineArrowHead.set({ left:pos.x, top:pos.y });
        previewLineArrowHead.set({ angle: calcurateArrowDegree(previewLine.x1, previewLine.y1, pos.x, pos.y) + 90 });
      }
      previewLine.setCoords();
      previewLineArrowHead && previewLineArrowHead.setCoords();
      canvas.renderAll();
    }
    function finalizeLineDrawingIfNeeded(domEvent){
      if (!pendingLineStart) return false;

      const hasPreview = !!previewLine;
      const x1 = hasPreview ? previewLine.x1 : pendingLineStart.x;
      const y1 = hasPreview ? previewLine.y1 : pendingLineStart.y;
      const x2 = hasPreview ? previewLine.x2 : canvas.getPointer(domEvent).x;
      const y2 = hasPreview ? previewLine.y2 : canvas.getPointer(domEvent).y;

      const minX = Math.min(x1, x2);
      const minY = Math.min(y1, y2);
      const p1 = { x: x1 - minX, y: y1 - minY };
      const p2 = { x: x2 - minX, y: y2 - minY };

      const shaftLine = new fabric.Line([p1.x, p1.y, p2.x, p2.y], {
        stroke: line_param.stroke, strokeWidth: line_param.strokeWidth, strokeLineCap: line_param.strokeLineCap,
      });
      const angleDeg = calcurateArrowDegree(x1, y1, x2, y2);
      const arrowHead = new fabric.Triangle({
        left:p2.x, top:p2.y, width:arrow_param.width, height:arrow_param.height, angle:angleDeg + 90,
        fill:arrow_param.fill, stroke:arrow_param.stroke, strokeWidth:arrow_param.strokeWidth,
        originX:arrow_param.originX, originY:arrow_param.originY,
      });

      const arrowGroup = new fabric.Group([shaftLine, arrowHead], { ...groupOptions, left:minX, top:minY });
      canvas.add(arrowGroup);
      canvas.setActiveObject(arrowGroup);

      if (previewLine){ canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead){ canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }
      pendingLineStart = null;
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      scheduleAutosave();
      pushHistory();
      return true;
    }
    function cancelLinePreview(render){
      if (previewLine){ canvas.remove(previewLine); previewLine = null; }
      if (previewLineArrowHead){ canvas.remove(previewLineArrowHead); previewLineArrowHead = null; }
      pendingLineStart = null;
      if (render) canvas.renderAll();
    }

    // ===== ユーティリティ =====
    function cycleFillColor(obj){
      let target = obj;
      if (obj && obj.type === 'group' && obj._objects && obj._objects.length){
        const shape = obj._objects.find(o => ['rect','circle','triangle','line','path'].includes(o.type));
        if (shape) target = shape;
      }
      if (!target) return;
      const current = (target.fill || color_palette[0]).toString();
      const idx = color_palette.indexOf(current);
      const next = color_palette[(idx + 1 + color_palette.length) % color_palette.length];
      target.set({ fill: next });
      canvas.renderAll();
    }
    function editLabelByDblClick(targetObject){
      if (!targetObject) return;
      const group = (targetObject.type === 'group') ? targetObject : targetObject.group;
      const isTextOnly = (targetObject.type === 'textbox' || targetObject.type === 'text');
      let labelText = null;

      if (group){
        labelText = group._label || (group._objects ? group._objects.find(o=>o.type==='text') : null);
        if (!labelText) return;
      }else if (isTextOnly){
        labelText = targetObject;
      }else return;

      const currentText = labelText.text || '';
      const nextText = window.prompt('図形のテキストを入力してください：', currentText);
      if (nextText === null) return;

      labelText.set({ text: nextText, textAlign:'center', originX:'center', originY:'center' });
      if (group){ centerGroupLabel(group); }
      (group || labelText).setCoords();
      canvas.renderAll();
    }
    function nudgeObject(obj, dx, dy){
      obj.set({ left: (obj.left||0)+dx, top: (obj.top||0)+dy });
      obj.setCoords();
      canvas.renderAll();
    }
    function duplicateObject(obj){
      if (!obj) return;
      obj.clone().then((clone) => {
        clone.set({ left: (obj.left || 0) + 32, top:  (obj.top  || 0) + 32 });
        canvas.add(clone);
        canvas.setActiveObject(clone);
        canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
        pushHistory();
      }).catch((err) => console.error('clone failed:', err));
    }
    function rotateObject(obj, deg){
      obj.rotate((obj.angle || 0) + deg);
      obj.setCoords();
      canvas.renderAll();
    }

    // ===== 削除（複数選択対応・修正版） =====
    function removeSelected(){
      const selected = canvas.getActiveObjects(); // v6: 配列で取得
      if (!selected || !selected.length) return;

      // ActiveSelectionが含まれていても、中身が個別に入るためそのまま削除
      selected.forEach(o => canvas.remove(o));
      canvas.discardActiveObject();
      canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
      scheduleAutosave();
      pushHistory();
    }

    // ===== イベント =====
    canvas.on('mouse:move', (evt) => {
      const p = canvas.getPointer(evt.e);
      lastPointer = { x: p.x, y: p.y };
      updateLinePreviewIfNeeded();
    });
    canvas.upperCanvasEl.addEventListener('dblclick', (domEvt) => {
      const target = canvas.findTarget(domEvt, true);
      if (!target) return;
      editLabelByDblClick(target);
    });
    canvas.on('mouse:down', (evt) => {
      if (finalizeLineDrawingIfNeeded(evt.e)) return;
      if (!evt.target){ canvas.discardActiveObject(); canvas.renderAll(); }
    });
    canvas.on('mouse:wheel', (opt) => {
      const delta = opt.e.deltaY;
      let z = canvas.getZoom();
      z *= 0.999**delta;
      z = Math.min(5,Math.max(0.2, z));
      canvas.zoomToPoint({x:opt.e.offsetX,y:opt.e.offsetY}, z);
      opt.e.preventDefault(); opt.e.stopPropagation();
      // ★ ズーム時は拡大率/右上ワールド座標のみ保存（updatedAtは変更しない）
      try{
        saveViewportMeta(currentSlot, { touchUpdatedAt: false });
      }catch(_){}
    });

    function handleKeydown(ev){
      const tag = (document.activeElement && document.activeElement.tagName) || '';
      if (tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT') return;
      if (ev.isComposing || ev.repeat) return;

      const keyLower = (ev.key || '').toLowerCase();
      const code = ev.code || '';
      const active = canvas.getActiveObject();
      const isCtrl = ev.ctrlKey || ev.metaKey;

      // Undo/Redo
      if (isCtrl && keyLower === 'z' && ev.shiftKey){ ev.preventDefault(); redo(); return; }
      if (isCtrl && keyLower === 'z'){ ev.preventDefault(); undo(); return; }

      // Select All
      if (isCtrl && (keyLower === 'a' || code === 'KeyA')){
        ev.preventDefault();
        const objs = canvas.getObjects();
        if (objs.length){
          const sel = new fabric.ActiveSelection(objs, { canvas });
          canvas.setActiveObject(sel);
          canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
        }
        return;
      }

      // 追加
      if (keyLower==='c' || code==='KeyC'){ ev.preventDefault(); addCircle(); scheduleAutosave(); pushHistory(); return; }
      if (keyLower==='s' || code==='KeyS'){ ev.preventDefault(); addRect();   scheduleAutosave(); pushHistory(); return; }
      if (keyLower==='t' || code==='KeyT'){ ev.preventDefault(); addTextBox(); scheduleAutosave(); pushHistory(); return; }

      // 線
      if (keyLower==='a' || code==='KeyA'){ ev.preventDefault(); startLineDrawing(); return; }
      if (keyLower==='escape' || code==='Escape'){ ev.preventDefault(); cancelLinePreview(true); return; }

      // 移動
      if (active){
        const step = ev.shiftKey ? 10 : 1;
        if (keyLower==='arrowup'){ ev.preventDefault(); nudgeObject(active,0,-step); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowdown'){ ev.preventDefault(); nudgeObject(active,0, step); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowleft'){ ev.preventDefault(); nudgeObject(active,-step,0); scheduleAutosave(); pushHistoryDebounced(); return; }
        if (keyLower==='arrowright'){ ev.preventDefault(); nudgeObject(active, step,0); scheduleAutosave(); pushHistoryDebounced(); return; }
      }

      // 複製（Ctrl+D）
      if (isCtrl && keyLower==='d'){ ev.preventDefault(); duplicateObject(active); scheduleAutosave(); return; }

      // Delete/Backspace
      if (keyLower==='delete' || keyLower==='backspace'){ ev.preventDefault(); removeSelected(); return; }
      // d キー（複数選択対応）
      if (keyLower==='d'){ ev.preventDefault(); removeSelected(); return; }

      // Enter: テキスト編集
      if (keyLower==='enter' || code==='Enter'){ ev.preventDefault(); if (active) editLabelByDblClick(active); scheduleAutosave(); pushHistoryDebounced(); return; }

      // Space: 色
      if (keyLower===' ' || keyLower==='spacebar' || code==='Space'){ ev.preventDefault(); if (active) cycleFillColor(active); scheduleAutosave(); pushHistoryDebounced(); return; }

      // 回転/スケール
      if (keyLower==='r'){ ev.preventDefault(); if (active) { rotateObject(active, ev.shiftKey ? -15 : 15); scheduleAutosave(); pushHistoryDebounced(); } return; }
      if (keyLower==='+'){ ev.preventDefault(); if (active){ active.set({ scaleX:(active.scaleX||1)*(ev.shiftKey?1.25:1.1), scaleY:(active.scaleY||1)*(ev.shiftKey?1.25:1.1) }); active.setCoords(); canvas.renderAll(); scheduleAutosave(); pushHistoryDebounced(); } return; }
      if (keyLower==='-'){ ev.preventDefault(); if (active){ active.set({ scaleX:(active.scaleX||1)*(ev.shiftKey?0.8:0.9),  scaleY:(active.scaleY||1)*(ev.shiftKey?0.8:0.9)  }); active.setCoords(); canvas.renderAll(); scheduleAutosave(); pushHistoryDebounced(); } return; }
    }
    window.addEventListener('keydown', handleKeydown, true);

    // クリックでフォーカス
    document.addEventListener('pointerdown', () => { canvasEl.focus({preventScroll:true}); });

    // Shift + ホイールでスロット切替
    canvas.upperCanvasEl.addEventListener('wheel', (e) => {
      if (!e.shiftKey) return;
      e.preventDefault();
      const dir = e.deltaY > 0 ? 1 : -1;
      selectSlot(currentSlot + dir);
      hideSlotPreview();
    }, { passive: false });

    // PNG出力
    pngBtn.addEventListener('click', () => {
      const dataURL = canvas.toDataURL({ format:'png', multiplier:2, enableRetinaScaling:false });
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = `canvas-slot${currentSlot+1}.png`;
      document.body.appendChild(a); a.click(); a.remove();
    });

    // 画像挿入
    imageBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'image/*';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = String(reader.result || ''); if (!dataURL) return;
          fabric.Image.fromURL(dataURL, (img) => {
            const drop = getDropPoint();
            const maxW = canvas.getWidth()*0.6, maxH = canvas.getHeight()*0.6;
            const scale = Math.min(1, maxW/img.width, maxH/img.height);
            img.set({ originX:'center', originY:'center', left:drop.x, top:drop.y, scaleX:scale, scaleY:scale, objectCaching:false });
            canvas.add(img);
            canvas.setActiveObject(img);
            canvas.requestRenderAll ? canvas.requestRenderAll() : canvas.renderAll();
            scheduleAutosave(); pushHistory();
          }, { crossOrigin: null });
        };
        reader.readAsDataURL(file);
      };
      input.click();
    });

    // クリア
    clearBtn.addEventListener('click', () => {
      const ok = window.confirm(`スロット ${currentSlot + 1} の全オブジェクトを削除します。\nこの操作は元に戻せません。よろしいですか？`);
      if (!ok) return;
      canvas.clear();
      setCanvasBg('#ffffff');
      // クリア直後の視点（ズーム1・原点）を保存しておく
      canvas.setViewportTransform([1,0,0,1,0,0]);
      saveToSlot(currentSlot); // 内部で meta も保存される
      resetHistoryBaseline();
    });

    // JSON入出力
    importBtn.addEventListener('click', () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'application/json';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try{
            canvas.clear(); setCanvasBg('#ffffff');
            applyingHistory = true;
            importCanvasJSON(String(reader.result), () => {
              applyingHistory = false;
              // インポート直後は今の視点（ズーム1/原点）。必要ならここで fit を入れてもよい。
              // 保存時に meta も併せて保存される。
              // （このアプリではスロット保存は saveToSlot() 経由で行い、そこに meta 保存が入っている）
              saveToSlot(currentSlot);
              resetHistoryBaseline();
              refreshSlotButtonsUI();
            });
          }catch(e){ console.error('import failed:', e); }
        };
        reader.readAsText(file);
      };
      input.click();
    });
    exportBtn.addEventListener('click', () => {
      const json = exportCanvasJSON();
      const blob = new Blob([json], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `canvas-export-slot${currentSlot+1}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    });

    // 初期化
    buildSlotButtons();
    resizeCanvasToViewport();
    currentSlot = 0;
    refreshSlotButtonsUI();
    loadFromSlot(currentSlot);
    canvasEl.focus({preventScroll:true});
    resetHistoryBaseline();

  })();
  </script>
</body>
</html>
